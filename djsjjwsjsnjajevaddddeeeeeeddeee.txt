-- ======================
local version = "5.7.9"
-- ======================

repeat task.wait() until game:IsLoaded()

if setfpscap then
    setfpscap(1000000)
    game:GetService("StarterGui"):SetCore("SendNotification", {
        Title = "dsc.gg/dyhub",
        Text = "FPS Unlocked!",
        Duration = 2,
        Button1 = "Okay"
    })
    warn("FPS Unlocked!")
else
    game:GetService("StarterGui"):SetCore("SendNotification", {
        Title = "dsc.gg/dyhub",
        Text = "Your exploit does not support setfpscap.",
        Duration = 2,
        Button1 = "Okay"
    })
    warn("Your exploit does not support setfpscap.")
end

if getgenv().Zutixhub then
    return
end
getgenv().Zutixhub = true
-- Load WindUI
local WindUI

do
    local ok, result = pcall(function()
        return require("./src/Init")
    end)
    
    if ok then
        WindUI = result
    else 
        WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()
    end
end


-- Localization setup
local Localization = WindUI:Localization({
    Enabled = true,
    Prefix = "loc:",
    DefaultLanguage = "en",
    Translations = {
        ["en"] = {
            ["SCRIPT_TITLE"] = "DYHUB",
            ["WELCOME"] = "Evade | Premium Version",
            ["INFO"] = "Information",
            ["FEATURES"] = "Features",
            ["Player_TAB"] = "Player",
            ["AUTO_TAB"] = "Auto",
            ["VISUALS_TAB"] = "Visuals",
            ["ESP_TAB"] = "ESP",
            ["SETTINGS_TAB"] = "Settings",
            ["INFINITE_JUMP"] = "Infinite Jump",
            ["JUMP_METHOD"] = "Infinite Jump Method",
            ["FLY"] = "Fly",
            ["FLY_SPEED"] = "Fly Speed",
            ["TPWALK"] = "TP WALK",
            ["TPWALK_VALUE"] = "TPWALK VALUE",
            ["JUMP_HEIGHT"] = "Jump Height",
            ["JUMP_POWER"] = "Jump Height",
            ["ANTI_AFK"] = "Anti AFK",
            ["NO_FOG"] = "Remove Fog",
            ["PLAYER_NAME_ESP"] = "Player Name ESP",
            ["PLAYER_BOX_ESP"] = "Player Box ESP",
            ["PLAYER_TRACER"] = "Player Tracer",
            ["PLAYER_DISTANCE_ESP"] = "Player Distance ESP",
            ["PLAYER_RAINBOW_BOXES"] = "Player Rainbow Boxes",
            ["PLAYER_RAINBOW_TRACERS"] = "Player Rainbow Tracers",
            ["NEXTBOT_ESP"] = "Nextbot ESP",
            ["NEXTBOT_NAME_ESP"] = "Nextbot Name ESP",
            ["DOWNED_BOX_ESP"] = "Downed Player Box ESP",
            ["DOWNED_TRACER"] = "Downed Player Tracer",
            ["DOWNED_NAME_ESP"] = "Downed Player Name ESP",
            ["DOWNED_DISTANCE_ESP"] = "Downed Player Distance ESP",
            ["AUTO_CARRY"] = "Auto Carry",
            ["AUTO_REVIVE"] = "Auto Revive",
            ["AUTO_VOTE"] = "Auto Vote",
            ["AUTO_VOTE_MAP"] = "Auto Vote Map",
            ["AUTO_SELF_REVIVE"] = "Auto Self Revive",
            ["MANUAL_REVIVE"] = "Manual Revive",
            ["AUTO_WIN"] = "Auto Win",
            ["AUTO_MONEY_FARM"] = "Auto Money Farm",
            ["SAVE_CONFIG"] = "Save Configuration",
            ["LOAD_CONFIG"] = "Load Configuration",
            ["THEME_SELECT"] = "Select Theme",
            ["TRANSPARENCY"] = "Window Transparency"
        }
    }
})

-- Set WindUI properties
WindUI.TransparencyValue = 0.2
WindUI:SetTheme("Dark")

-- Create WindUI window
local Window = WindUI:CreateWindow({
    Title = "loc:SCRIPT_TITLE",
    Icon = "rbxassetid://104487529937663",
    Author = "loc:WELCOME",
    Folder = "DYHUB_EVADE_REWORK",
    Size = UDim2.fromOffset(580, 490),
    Theme = "Dark",
    HidePanelBackground = false,
    Acrylic = false,
    HideSearchBar = false,
    HasOutline = false,
    ScrollBarEnabled = true,
    SideBarWidth = 200,
    User = { Enabled = true, Anonymous = false },
})
local isWindowOpen = false
local function updateWindowOpenState()
    if Window and type(Window.IsOpen) == "function" then
        local ok, val = pcall(function() return Window:IsOpen() end)
        if ok and type(val) == "boolean" then
            isWindowOpen = val
            return
        end
    end
    if Window and Window.Opened ~= nil then
        isWindowOpen = Window.Opened
        return
    end
    isWindowOpen = isWindowOpen or false
end

pcall(updateWindowOpenState)
featureStates = featureStates or {}
if featureStates.DisableCameraShake == nil then
    featureStates.DisableCameraShake = false
end
Window:SetToggleKey(Enum.KeyCode.K)
Window:Tag({
Title = version,
Color = Color3.fromHex("#30ff6a")
})

Window:CreateTopbarButton("theme-switcher", "moon", function()
    WindUI:SetTheme(WindUI:GetCurrentTheme() == "Dark" and "Light" or "Dark")
end, 990)

Window:EditOpenButton({
    Title = "DYHUB - Open",
    Icon = "monitor",
    CornerRadius = UDim.new(0, 6),
    StrokeThickness = 2,
    Color = ColorSequence.new(Color3.fromRGB(30, 30, 30), Color3.fromRGB(255, 255, 255)),
    Draggable = true,
})

-- Services
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local VirtualUser = game:GetService("VirtualUser")
local Lighting = game:GetService("Lighting")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local workspace = game:GetService("Workspace")
local originalGameGravity = workspace.Gravity
local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService")
local MarketplaceService = game:GetService("MarketplaceService")
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
local placeId = game.PlaceId
local jobId = game.JobId
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")
local player = Players.LocalPlayer
local camera = workspace.CurrentCamera
local mouse = player:GetMouse()
local FREECAM_SPEED = 50
local SENSITIVITY = 0.002
local ZOOM_SPEED = 10
local MIN_ZOOM = 2
local MAX_ZOOM = 100
local FOV_SPEED = 5
local MIN_FOV = 10
local MAX_FOV = 120
local DEFAULT_FOV = 70
local isFreecamEnabled = false
local isFreecamMovementEnabled = true
local cameraPosition = Vector3.new(0, 10, 0)
local cameraRotation = Vector2.new(0, 0)
local JUMP_FORCE = 50
local isMobile = not UserInputService.KeyboardEnabled
local touchConnection
local lastTouchPosition = nil
local lastYPosition = nil
local isJumping = false
local isAltHeld = false
local heartbeatConnection
local inputChangedConnection
local characterAddedConnection
local dragging = false
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "FreecamGui"
screenGui.Parent = player.PlayerGui
screenGui.ResetOnSpawn = false
local controlFrame = Instance.new("Frame")
controlFrame.Name = "ControlFrame"
controlFrame.Size = UDim2.new(0, 140, 0, 150)
controlFrame.Position = UDim2.new(0, 10, 0, 10)
controlFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
controlFrame.BackgroundTransparency = 1
controlFrame.BorderSizePixel = 2
controlFrame.BorderColor3 = Color3.fromRGB(100, 100, 100)
controlFrame.Visible = false 
controlFrame.Parent = screenGui
local freecamButton = Instance.new("TextButton")
freecamButton.Name = "FreecamButton"
freecamButton.Text = "Enable Freecam"
freecamButton.Size = UDim2.new(0, 120, 0, 30)
freecamButton.Position = UDim2.new(0, 10, 0, 0)
freecamButton.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
freecamButton.TextColor3 = Color3.fromRGB(255, 255, 255)
freecamButton.Font = Enum.Font.SourceSans
freecamButton.TextSize = 14
freecamButton.Parent = controlFrame

local movementButton = Instance.new("TextButton")
movementButton.Name = "MovementButton"
movementButton.Text = "Control Player "
movementButton.Size = UDim2.new(0, 120, 0, 30)
movementButton.Position = UDim2.new(0, 10, 0, 35)
movementButton.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
movementButton.TextColor3 = Color3.fromRGB(255, 255, 255)
movementButton.Font = Enum.Font.SourceSans
movementButton.TextSize = 14
movementButton.Visible = false
movementButton.Parent = controlFrame

local sliderFrame = Instance.new("Frame")
sliderFrame.Name = "FOVSliderFrame"
sliderFrame.Size = UDim2.new(0, 120, 0, 60)
sliderFrame.Position = UDim2.new(0, 10, 0, 70)
sliderFrame.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
sliderFrame.BorderSizePixel = 0
sliderFrame.Visible = false
sliderFrame.Parent = controlFrame
local fovLabel = Instance.new("TextLabel")
fovLabel.Name = "FOVLabel"
fovLabel.Size = UDim2.new(1, 0, 0, 15)
fovLabel.Position = UDim2.new(0, 0, 0, 5)
fovLabel.BackgroundTransparency = 1
fovLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
fovLabel.Font = Enum.Font.SourceSans
fovLabel.TextSize = 12
fovLabel.Text = "FOV: " .. DEFAULT_FOV
fovLabel.Parent = sliderFrame

local sliderBar = Instance.new("Frame")
sliderBar.Name = "SliderBar"
sliderBar.Size = UDim2.new(0, 100, 0, 8)
sliderBar.Position = UDim2.new(0, 10, 0, 35)
sliderBar.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
sliderBar.Parent = sliderFrame

local sliderHandle = Instance.new("TextButton")
sliderHandle.Name = "SliderHandle"
sliderHandle.Size = UDim2.new(0, 16, 0, 16)
sliderHandle.Position = UDim2.new(0, (DEFAULT_FOV - MIN_FOV) / (MAX_FOV - MIN_FOV) * 100 - 8, 0, -4)
sliderHandle.BackgroundColor3 = Color3.fromRGB(200, 200, 200)
sliderHandle.Text = ""
sliderHandle.Parent = sliderBar
local function updateFOV()
    local sliderPos = sliderHandle.Position.X.Offset
    local normalizedValue = math.clamp((sliderPos + 8) / 100, 0, 1)
    local newFOV = MIN_FOV + normalizedValue * (MAX_FOV - MIN_FOV)
    camera.FieldOfView = math.clamp(newFOV, MIN_FOV, MAX_FOV)
    fovLabel.Text = "FOV: " .. math.floor(camera.FieldOfView + 0.5)
end

sliderHandle.MouseButton1Down:Connect(function()
    dragging = true
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = false
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
        local mousePos = input.Position.X
        local barPos = sliderBar.AbsolutePosition.X
        local barWidth = sliderBar.AbsoluteSize.X
        local newX = math.clamp(mousePos - barPos - 8, -8, barWidth - 8)
        sliderHandle.Position = UDim2.new(0, newX, 0, -4)
        updateFOV()
    end
end)
local playerCage = nil
local CAGE_SIZE = Vector3.new(6, 8, 6)
local CAGE_OFFSET = Vector3.new(0, -3, 0)

local function createPlayerCage(position)
    if playerCage then
        playerCage:Destroy()
        playerCage = nil
    end
    
    playerCage = Instance.new("Folder")
    playerCage.Name = "PlayerCage"
    playerCage.Parent = workspace
    
    local cageCFrame = CFrame.new(position + CAGE_OFFSET)
    
    local function createCagePart(size, cframeOffset, name)
        local part = Instance.new("Part")
        part.Name = name
        part.Size = size
        part.CFrame = cageCFrame * cframeOffset
        part.Anchored = true
        part.CanCollide = true
        part.Transparency = 1
        part.BrickColor = BrickColor.new("Institutional white")
        part.Material = Enum.Material.ForceField
        part.Parent = playerCage
        return part
    end
    
    -- Floor (prevents falling)
    local floorPart = createCagePart(Vector3.new(CAGE_SIZE.X + 0.2, 0.2, CAGE_SIZE.Z + 0.2), CFrame.new(0, -CAGE_SIZE.Y / 2, 0), "Floor")
    
    -- Ceiling (prevents upward escape/jump)
    createCagePart(Vector3.new(CAGE_SIZE.X + 0.2, 0.2, CAGE_SIZE.Z + 0.2), CFrame.new(0, CAGE_SIZE.Y / 2, 0), "Ceiling")
    
    -- Walls (prevents horizontal movement)
    local wallThickness = 0.2
    -- Front wall
    createCagePart(Vector3.new(CAGE_SIZE.X + 0.2, CAGE_SIZE.Y, wallThickness), CFrame.new(0, 0, -CAGE_SIZE.Z / 2), "FrontWall")
    -- Back wall
    createCagePart(Vector3.new(CAGE_SIZE.X + 0.2, CAGE_SIZE.Y, wallThickness), CFrame.new(0, 0, CAGE_SIZE.Z / 2), "BackWall")
    -- Left wall
    createCagePart(Vector3.new(wallThickness, CAGE_SIZE.Y, CAGE_SIZE.Z + 0.2), CFrame.new(-CAGE_SIZE.X / 2, 0, 0), "LeftWall")
    -- Right wall
    createCagePart(Vector3.new(wallThickness, CAGE_SIZE.Y, CAGE_SIZE.Z + 0.2), CFrame.new(CAGE_SIZE.X / 2, 0, 0), "RightWall")
    
    playerCage.PrimaryPart = floorPart
end

local function destroyPlayerCage()
    if playerCage then
        playerCage:Destroy()
        playerCage = nil
    end
end

local function freezePlayer(character)
    local humanoid = character and character:FindFirstChildOfClass("Humanoid")
    local rootPart = character and character:FindFirstChild("HumanoidRootPart")
    if not humanoid or not rootPart then return end
    
    lastYPosition = rootPart.Position.Y
    
    local diedConnection
    diedConnection = humanoid.Died:Connect(function()
        destroyPlayerCage() 
        deactivateFreecam()
        diedConnection:Disconnect()
    end)
    
    if heartbeatConnection then heartbeatConnection:Disconnect() end
    heartbeatConnection = RunService.Heartbeat:Connect(function(dt)
        if not isFreecamEnabled or not character.Parent then
            destroyPlayerCage()
            if rootPart then rootPart.Anchored = false end
            return
        end
        
        local shouldCage = isFreecamMovementEnabled and not isAltHeld
        if shouldCage then
    if not playerCage then
        createPlayerCage(rootPart.Position)
    else
        local newPos = rootPart.Position + CAGE_OFFSET
        playerCage:SetPrimaryPartCFrame(CFrame.new(newPos))
    end
else
    destroyPlayerCage()
end
        
        if isFreecamMovementEnabled then
            local currentY = rootPart.Position.Y
            if humanoid.FloorMaterial == Enum.Material.Air and not isJumping then
                local gravity = -196.2 * dt
                currentY = currentY + gravity * dt
            end
            rootPart.Position = Vector3.new(rootPart.Position.X, currentY, rootPart.Position.Z)
            lastYPosition = currentY
        end
    end)
end

UserInputService.JumpRequest:Connect(function()
    if not isFreecamEnabled or not isFreecamMovementEnabled then return end
    local character = player.Character
    local humanoid = character and character:FindFirstChildOfClass("Humanoid")
    local rootPart = character and character:FindFirstChild("HumanoidRootPart")
    if humanoid and rootPart and humanoid.FloorMaterial ~= Enum.Material.Air then
        isJumping = true
        local currentY = rootPart.Position.Y
        rootPart.Position = Vector3.new(rootPart.Position.X, currentY + JUMP_FORCE * 0.1, rootPart.Position.Z)
        task.delay(0.5, function() isJumping = false end)
    end
end)

local function updateCamera(dt)
    if not isFreecamEnabled or isAltHeld then return end
    local character = player.Character
    local humanoid = character and character:FindFirstChildOfClass("Humanoid")
    local moveVector = Vector3.new(0, 0, 0)
    if isFreecamMovementEnabled and humanoid and humanoid.MoveDirection.Magnitude > 0 then
        local forward = camera.CFrame.LookVector
        local right = camera.CFrame.RightVector
        local forwardComponent = humanoid.MoveDirection:Dot(forward) * forward
        local rightComponent = humanoid.MoveDirection:Dot(right) * right
        moveVector = forwardComponent + rightComponent
    end
    if isFreecamMovementEnabled then
        if UserInputService:IsKeyDown(Enum.KeyCode.E) or UserInputService:IsKeyDown(Enum.KeyCode.Space) then
            moveVector = moveVector + Vector3.new(0, 1, 0)
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.Q) or UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) then
            moveVector = moveVector - Vector3.new(0, 1, 0)
        end
    end
    if moveVector.Magnitude > 0 then
        moveVector = moveVector.Unit * FREECAM_SPEED * dt
        cameraPosition = cameraPosition + moveVector
    end
    
    camera.CameraType = Enum.CameraType.Scriptable
    local rotationCFrame = CFrame.Angles(0, cameraRotation.Y, 0) * CFrame.Angles(cameraRotation.X, 0, 0)
    camera.CFrame = CFrame.new(cameraPosition) * rotationCFrame
end

local function onMouseMove(input)
    if not isFreecamEnabled or isMobile or dragging then return end
    cameraRotation = cameraRotation + Vector2.new(-input.Delta.Y * SENSITIVITY, -input.Delta.X * SENSITIVITY)
    cameraRotation = Vector2.new(math.clamp(cameraRotation.X, -math.pi/2, math.pi/2), cameraRotation.Y)
end

local function onTouchMoved(input, gameProcessed)
    if not isFreecamEnabled or gameProcessed or dragging then return end
    
    if lastTouchPosition then
        local delta = input.Position - lastTouchPosition
        cameraRotation = cameraRotation + Vector2.new(-delta.Y * SENSITIVITY / 0.1, -delta.X * SENSITIVITY / 0.1)
        cameraRotation = Vector2.new(math.clamp(cameraRotation.X, -math.pi/2, math.pi/2), cameraRotation.Y)
    end
    lastTouchPosition = input.Position
end

local function onTouchEnded(input)
    lastTouchPosition = nil
end

local function onScroll(input)
    if not isFreecamEnabled or isMobile then return end
    if input.UserInputType == Enum.UserInputType.MouseWheel then
        local zoomDirection = input.Position.Z
        local isCtrlHeld = UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) or UserInputService:IsKeyDown(Enum.KeyCode.RightControl)
        local isAltHeld = UserInputService:IsKeyDown(Enum.KeyCode.LeftAlt) or UserInputService:IsKeyDown(Enum.KeyCode.RightAlt)
        
        if isCtrlHeld then
            local newFOV = camera.FieldOfView - zoomDirection * FOV_SPEED
            camera.FieldOfView = math.clamp(newFOV, MIN_FOV, MAX_FOV)
            fovLabel.Text = "FOV: " .. math.floor(camera.FieldOfView + 0.5)
            sliderHandle.Position = UDim2.new(0, (camera.FieldOfView - MIN_FOV) / (MAX_FOV - MIN_FOV) * 100 - 8, 0, -4)
        elseif isAltHeld and isFreecamMovementEnabled then
            local zoomAmount = zoomDirection * ZOOM_SPEED
            local lookVector = camera.CFrame.LookVector
            local newPosition = cameraPosition + lookVector * zoomAmount
            local distance = (newPosition - (cameraPosition + lookVector * MIN_ZOOM)).Magnitude
            if distance >= MIN_ZOOM and distance <= MAX_ZOOM then
                cameraPosition = newPosition
            end
        elseif isFreecamMovementEnabled then
            local zoomAmount = zoomDirection * ZOOM_SPEED
            local lookVector = camera.CFrame.LookVector
            local newPosition = cameraPosition + lookVector * zoomAmount
            local distance = (newPosition - (cameraPosition + lookVector * MIN_ZOOM)).Magnitude
            if distance >= MIN_ZOOM and distance <= MAX_ZOOM then
                cameraPosition = newPosition
            end
        end
    end
end

local function reloadFreecam()
    isFreecamEnabled = false
    isFreecamMovementEnabled = true
    camera.CameraType = Enum.CameraType.Custom
    camera.FieldOfView = DEFAULT_FOV
    UserInputService.MouseBehavior = Enum.MouseBehavior.Default
    cameraPosition = Vector3.new(0, 10, 0)
    cameraRotation = Vector2.new(0, 0)
    dragging = false
    destroyPlayerCage()
    
    if heartbeatConnection then heartbeatConnection:Disconnect() end
    if touchConnection then touchConnection:Disconnect() end
    if inputChangedConnection then inputChangedConnection:Disconnect() end
    freecamButton.Text = "Enable Freecam"
    movementButton.Text = "Control Player "
    movementButton.Visible = false
    sliderFrame.Visible = false
    fovLabel.Text = "FOV: " .. DEFAULT_FOV
    sliderHandle.Position = UDim2.new(0, (DEFAULT_FOV - MIN_FOV) / (MAX_FOV - MIN_FOV) * 100 - 8, 0, -4)
end

local function activateFreecam()
    if isFreecamEnabled then return end
    isFreecamEnabled = true
    isFreecamMovementEnabled = true
    camera.CameraType = Enum.CameraType.Scriptable
    camera.FieldOfView = DEFAULT_FOV
    
    cameraPosition = camera.CFrame.Position
    local lookVector = camera.CFrame.LookVector
    cameraRotation = Vector2.new(math.asin(-lookVector.Y), math.atan2(-lookVector.X, lookVector.Z))
    
    UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
    freecamButton.Text = "Disable Freecam"
    movementButton.Text = "Control Player "
    movementButton.Visible = true
    sliderFrame.Visible = true
    fovLabel.Text = "FOV: " .. DEFAULT_FOV
    sliderHandle.Position = UDim2.new(0, (DEFAULT_FOV - MIN_FOV) / (MAX_FOV - MIN_FOV) * 100 - 8, 0, -4)
    
    if player.Character then
        freezePlayer(player.Character)
    end
    
    if characterAddedConnection then characterAddedConnection:Disconnect() end
    characterAddedConnection = player.CharacterAdded:Connect(function()
        reloadFreecam()
    end)
    
    if isMobile then
        if touchConnection then touchConnection:Disconnect() end
        touchConnection = UserInputService.TouchMoved:Connect(onTouchMoved)
        UserInputService.TouchEnded:Connect(onTouchEnded)
    end
    
    if inputChangedConnection then inputChangedConnection:Disconnect() end
    inputChangedConnection = UserInputService.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement then
            onMouseMove(input)
        elseif input.UserInputType == Enum.UserInputType.MouseWheel then
            onScroll(input)
        end
    end)
end

local function deactivateFreecam()
    if not isFreecamEnabled then return end
    isFreecamEnabled = false
    isFreecamMovementEnabled = true
    isAltHeld = false
    dragging = false
    camera.CameraType = Enum.CameraType.Custom
    camera.FieldOfView = DEFAULT_FOV
    UserInputService.MouseBehavior = Enum.MouseBehavior.Default
    destroyPlayerCage()
    freecamButton.Text = "Enable Freecam"
    movementButton.Text = "Control Player "
    movementButton.Visible = false
    sliderFrame.Visible = false
    fovLabel.Text = "FOV: " .. DEFAULT_FOV
    sliderHandle.Position = UDim2.new(0, (DEFAULT_FOV - MIN_FOV) / (MAX_FOV - MIN_FOV) * 100 - 8, 0, -4)
    
    if player.Character then
        local rootPart = player.Character:FindFirstChild("HumanoidRootPart")
        if rootPart then rootPart.Anchored = false end
    end
    
    if heartbeatConnection then heartbeatConnection:Disconnect() end
    if touchConnection then touchConnection:Disconnect() end
end

freecamButton.MouseButton1Click:Connect(function()
    if isFreecamEnabled then
        deactivateFreecam()
    else
        activateFreecam()
    end
end)


movementButton.MouseButton1Click:Connect(function()
    isFreecamMovementEnabled = not isFreecamMovementEnabled
    movementButton.Text = isFreecamMovementEnabled and "Control Player " or "Control Freecam"
    if player.Character then
        local rootPart = player.Character:FindFirstChild("HumanoidRootPart")
        if rootPart then
            rootPart.Anchored = false
        end
    end
end)

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Enum.KeyCode.LeftAlt or input.KeyCode == Enum.KeyCode.RightAlt then
        if isFreecamEnabled then
            isAltHeld = true
            if player.Character then
                local rootPart = player.Character:FindFirstChild("HumanoidRootPart")
                if rootPart then
                    rootPart.Anchored = false
                end
            end
        end
    elseif input.KeyCode == Enum.KeyCode.P and (UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) or UserInputService:IsKeyDown(Enum.KeyCode.RightControl)) then
        if isFreecamEnabled then
            deactivateFreecam()
        else
            activateFreecam()
        end
    end
end)
UserInputService.InputEnded:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Enum.KeyCode.LeftAlt or input.KeyCode == Enum.KeyCode.RightAlt then
        if isFreecamEnabled then
            isAltHeld = false
            if player.Character then
                local rootPart = player.Character:FindFirstChild("HumanoidRootPart")
                if rootPart then
                    rootPart.Anchored = false
                end
            end
        end
    end
end)

RunService.Heartbeat:Connect(updateCamera)
if characterAddedConnection then characterAddedConnection:Disconnect() end
characterAddedConnection = player.CharacterAdded:Connect(function()
    reloadFreecam()
end)
local currentSettings = {
    Speed = "1500",
    JumpCap = "1",
    AirStrafeAcceleration = "187"
}
local appliedOnce = false
local playerModelPresent = false
local gameStatsPath = workspace:WaitForChild("Game"):WaitForChild("Stats")
getgenv().ApplyMode = "Not Optimized"
local requiredFields = {
    Friction = true,
    AirStrafeAcceleration = true,
    JumpHeight = true,
    RunDeaccel = true,
    JumpSpeedMultiplier = true,
    JumpCap = true,
    SprintCap = true,
    WalkSpeedMultiplier = true,
    BhopEnabled = true,
    Speed = true,
    AirAcceleration = true,
    RunAccel = true,
    SprintAcceleration = true
}

local function hasAllFields(tbl)
    if type(tbl) ~= "table" then return false end
    for field, _ in pairs(requiredFields) do
        if rawget(tbl, field) == nil then return false end
    end
    return true
end

local function getConfigTables()
    local tables = {}
    for _, obj in ipairs(getgc(true)) do
        local success, result = pcall(function()
            if hasAllFields(obj) then return obj end
        end)
        if success and result then
            table.insert(tables, result)
        end
    end
    return tables
end

local function applyToTables(callback)
    local targets = getConfigTables()
    if #targets == 0 then return end
    
    if getgenv().ApplyMode == "Optimized" then
        task.spawn(function()
            for i, tableObj in ipairs(targets) do
                if tableObj and typeof(tableObj) == "table" then
                    pcall(callback, tableObj)
                end
                
                if i % 3 == 0 then
                    task.wait()
                end
            end
        end)
    else
        for i, tableObj in ipairs(targets) do
            if tableObj and typeof(tableObj) == "table" then
                pcall(callback, tableObj)
            end
        end
    end
end

local function applyStoredSettings()
    local settings = {
        {field = "Speed", value = tonumber(currentSettings.Speed)},
        {field = "JumpCap", value = tonumber(currentSettings.JumpCap)},
        {field = "AirStrafeAcceleration", value = tonumber(currentSettings.AirStrafeAcceleration)}
    }
    
    for _, setting in ipairs(settings) do
        if setting.value and tostring(setting.value) ~= "1500" and tostring(setting.value) ~= "1" and tostring(setting.value) ~= "187" then
            applyToTables(function(obj)
                obj[setting.field] = setting.value
            end)
        end
    end
end

local function applySettingsWithDelay()
    if not playerModelPresent or appliedOnce then
        return
    end
    
    appliedOnce = true
    
    local settings = {
        {field = "Speed", value = tonumber(currentSettings.Speed), delay = math.random(1, 14)},
        {field = "JumpCap", value = tonumber(currentSettings.JumpCap), delay = math.random(1, 14)},
        {field = "AirStrafeAcceleration", value = tonumber(currentSettings.AirStrafeAcceleration), delay = math.random(1, 14)}
    }
    
    for _, setting in ipairs(settings) do
        if setting.value and tostring(setting.value) ~= "1500" and tostring(setting.value) ~= "1" and tostring(setting.value) ~= "187" then
            task.spawn(function()
                task.wait(setting.delay)
                applyToTables(function(obj)
                    obj[setting.field] = setting.value
                end)
            end)
        end
    end
end

local function isPlayerModelPresent()
    local GameFolder = workspace:FindFirstChild("Game")
    local PlayersFolder = GameFolder and GameFolder:FindFirstChild("Players")
    return PlayersFolder and PlayersFolder:FindFirstChild(player.Name) ~= nil
end
local featureStates = {
    AutoWhistle = false,
    CustomGravity = false,
    GravityValue = originalGameGravity,
    InfiniteJump = false,
    Fly = false,
    TPWALK = false,
    JumpBoost = false,
    AntiAFK = false,
    AutoCarry = false,
    NoFog = false,
    AutoVote = false,
    AutoSelfRevive = false,
    AutoWin = false,
    AutoMoneyFarm = false,
    AutoRevive = false,
    FastRevive = false,
    DisableCameraShake = false,
    PlayerESP = {
        boxes = false,
        tracers = false,
        names = false,
        distance = false,
        rainbowBoxes = false,
        rainbowTracers = false,
        boxType = "2D",
    },
    NextbotESP = {
        boxes = false,
        tracers = false,
        names = false,
        distance = false,
        rainbowBoxes = false,
        rainbowTracers = false,
        boxType = "2D",
    },
    DownedBoxESP = false,
    DownedTracer = false,
    DownedNameESP = false,
    DownedDistanceESP = false,
    DownedBoxType = "2D",
    FlySpeed = 5,
    TpwalkValue = 1,
    JumpPower = 5,
    JumpMethod = "Hold",
    SelectedMap = 1,
    ZoomValue = 1,
    TimerDisplay = false
}
-- Variables
local Events = ReplicatedStorage:WaitForChild("Events",10)
local CharacterFolder = Events:WaitForChild("Character",10)
local EmoteRemote = CharacterFolder:WaitForChild("Emote",10)
local PassCharacterInfo = CharacterFolder:WaitForChild("PassCharacterInfo",10)

local remoteSignal = PassCharacterInfo and PassCharacterInfo.OnClientEvent
local currentTag = nil
local currentEmotes = table.create(12,"")
local selectEmotes = table.create(12,"")
local emoteEnabled = table.create(12,false)

local function readTagFromFolder(f)
    local a = f:GetAttribute("Tag")
    if a ~= nil then return a end
    local o = f:FindFirstChild("Tag")
    if o and o:IsA("ValueBase") then return o.Value end
    return nil
end

local function onRespawn()
    repeat task.wait() until workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Players")
    local pf = workspace.Game.Players:WaitForChild(player.Name,10)
    if not pf then warn("Player folder missing after respawn"); currentTag=nil; return end
    currentTag = readTagFromFolder(pf)
    if currentTag then
        local b = tonumber(currentTag)
        if b and b>=0 and b<=255 then
            print(string.format("Respawn to TAG captured: %d",b))
        else
            warn(string.format("Respawn to Invalid TAG: %s",tostring(currentTag)))
            currentTag=nil
        end
    else
        print("Respawn to No TAG found")
        currentTag=nil
    end
end

local pendingSlot = nil
local function fireSelect(slot)
    if not currentTag then return end
    local b = tonumber(currentTag)
    local buf = buffer.create(2)
    buffer.writeu8(buf,0,b)
    buffer.writeu8(buf,1,17)
    if remoteSignal then
        firesignal(remoteSignal,buf,{selectEmotes[slot]})
        print(string.format("Fired %s with byte \\%d\\17 (TAG=%d)",selectEmotes[slot],b,b))
    end
end

local function fireEmoteDirectly(emoteName)
    pcall(function()
        EmoteRemote:FireServer(emoteName)
        print(string.format("Fallback: Directly fired emote: %s", emoteName))
    end)
end

if PassCharacterInfo then
    PassCharacterInfo.OnClientEvent:Connect(function()
        if not pendingSlot then return end
        fireSelect(pendingSlot)
        pendingSlot = nil
    end)

    local oldNamecall
    oldNamecall = hookmetamethod(game,"__namecall",function(self,...)
        local m = getnamecallmethod()
        local a = {...}
        if m=="FireServer" and self==EmoteRemote and type(a[1])=="string" then
            for i=1,12 do
                if emoteEnabled[i] and currentEmotes[i]~="" and a[1]==currentEmotes[i] then
                    pendingSlot = i
                    local targetEmote = selectEmotes[i]
                    print("Detected current emote:",currentEmotes[i],"waiting for PassCharacterInfo...")
                     local timeoutTask = task.spawn(function()
                        local startTime = tick()
                        while pendingSlot == i and (tick() - startTime) < 2 do 
                            task.wait(0.1)
                        end
                        
                        if pendingSlot == i then
                            print(string.format("Timeout: PassCharacterInfo failed after 2s, firing emote directly: %s", targetEmote))
                            fireEmoteDirectly(targetEmote)
                            pendingSlot = nil
                        end
                    end)
                    
                    return
                end
            end
        end
        return oldNamecall(self,...)
    end)

    if player.Character then
        onRespawn()
    end
    player.CharacterAdded:Connect(onRespawn)
else
    warn("PassCharacterInfo not found, using direct emote firing")
    local oldNamecall = hookmetamethod(game,"__namecall",function(self,...)
        local m = getnamecallmethod()
        local a = {...}
        if m=="FireServer" and self==EmoteRemote and type(a[1])=="string" then
            for i=1,12 do
                if emoteEnabled[i] and currentEmotes[i]~="" and a[1]==currentEmotes[i] then
                    local targetEmote = selectEmotes[i]
                    print(string.format("Direct emote replacement: %s -> %s", currentEmotes[i], targetEmote))
                    fireEmoteDirectly(targetEmote)
                    return
                end
            end
        end
        return oldNamecall(self,...)
    end)
end
local character, humanoid, rootPart
local isJumpHeld = false
local hasRevived = false
local flying = false
local bodyVelocity, bodyGyro
local ToggleTpwalk = false
local TpwalkConnection
getgenv().ticketfarm = false
getgenv().moneyfarm = false
if not featureStates.AntiNextbotDistance then
    featureStates.AntiNextbotDistance = 50
end

local previousMoneyFarm = false
local previousTicketFarm = false
local previousAutoWin = false
local farmsSuppressedByAntiNextbot = false
local antiNextbotConnection = nil
local jumpCount = 0
local MAX_JUMPS = math.huge

local AntiAFKConnection

local AutoCarryConnection

local reviveRange = 10
local loopDelay = 0.15
local reviveLoopHandle = nil
local interactEvent = ReplicatedStorage:WaitForChild("Events"):WaitForChild("Character"):WaitForChild("Interact")
local featureStates = featureStates or {}
featureStates.FastReviveMethod = "Interact"
featureStates.reviveHook = nil
featureStates.interactHookActive = false

-- Visual Variables
local originalBrightness = Lighting.Brightness
local originalFogEnd = Lighting.FogEnd
local originalOutdoorAmbient = Lighting.OutdoorAmbient
local originalAmbient = Lighting.Ambient
local originalGlobalShadows = Lighting.GlobalShadows
local originalAtmospheres = {}

for _, v in pairs(Lighting:GetDescendants()) do
    if v:IsA("Atmosphere") then
        table.insert(originalAtmospheres, v)
    end
end
local function startNoFog()
    originalFogEnd = Lighting.FogEnd
    Lighting.FogEnd = 1000000
    for _, v in pairs(Lighting:GetDescendants()) do
        if v:IsA("Atmosphere") then
            v:Destroy()
        end
    end
end
local function isPlayerGrounded()
    if not character or not humanoid or not rootPart then
        return false
    end
    local rayOrigin = rootPart.Position
    local rayDirection = Vector3.new(0, -3, 0)
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {character}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    local raycastResult = workspace:Raycast(rayOrigin, rayDirection, raycastParams)
    return raycastResult ~= nil
end

local function bouncePlayer()
    if character and humanoid and rootPart and humanoid.Health > 0 then
        if not isPlayerGrounded() then
            humanoid.Jump = true
            local jumpVelocity = math.sqrt(1.5 * humanoid.JumpHeight * workspace.Gravity) * 1.5
            rootPart.Velocity = Vector3.new(rootPart.Velocity.X, jumpVelocity * humanoid.JumpPower / 50, rootPart.Velocity.Z)
        end
    end
end

local function getDistanceFromPlayer(targetPosition)
    if not character or not rootPart then return 0 end
    return (targetPosition - rootPart.Position).Magnitude
end

local function isPlayerDowned(pl)
    if not pl or not pl.Character then return false end
    local char = pl.Character
    local humanoid = char:FindFirstChild("Humanoid")
    if humanoid and humanoid.Health <= 0 then
        return true
    end
    if char.GetAttribute and char:GetAttribute("Downed") == true then
        return true
    end
    return false
end
local function isPlayerDowned(pl)
    local char = pl.Character
    if char and char:FindFirstChild("Humanoid") then
        local humanoid = char.Humanoid
        return humanoid.Health <= 0 or char:GetAttribute("Downed") == true
    end
    return false
end

local function startAutoRevive()
    if featureStates.FastReviveMethod == "Auto" then
        if reviveLoopHandle then return end
        
        reviveLoopHandle = task.spawn(function()
            while featureStates.FastRevive do
                local LocalPlayer = Players.LocalPlayer
                if LocalPlayer and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    local myHRP = LocalPlayer.Character.HumanoidRootPart
                    for _, pl in ipairs(Players:GetPlayers()) do
                        if pl ~= LocalPlayer then
                            local char = pl.Character
                            if char and char:FindFirstChild("HumanoidRootPart") then
                                if isPlayerDowned(pl) then
                                    local hrp = char.HumanoidRootPart
                                    local success, dist = pcall(function()
                                        return (myHRP.Position - hrp.Position).Magnitude
                                    end)
                                    if success and dist and dist <= reviveRange then
                                        pcall(function()
                                            interactEvent:FireServer("Revive", true, pl.Name)
                                        end)
                                    end
                                end
                            end
                        end
                    end
                end
                task.wait(loopDelay)
            end
            reviveLoopHandle = nil
        end)
    elseif featureStates.FastReviveMethod == "Interact" then
        if not featureStates.interactHookActive then
            local localPlayer = Players.LocalPlayer
            local eventsFolder = localPlayer.PlayerScripts:WaitForChild("Events")
            local tempEventsFolder = eventsFolder:WaitForChild("temporary_events")
            local useKeybind = tempEventsFolder:WaitForChild("UseKeybind")
            
            local connection = useKeybind.Event:Connect(function(...)
                local args = {...}
                
                if args[1] and type(args[1]) == "table" then
                    local keyData = args[1]
                    
                    if keyData.Key == "Interact" and keyData.Down == true and featureStates.FastRevive then
                        local function reviveAllPlayers()
                            local ohString1 = "Revive"
                            local ohBoolean2 = true
                            
                            for _, player in pairs(Players:GetPlayers()) do
                                if player ~= localPlayer then
                                        local ohString3 = player.Name
                                        pcall(function()
                                            interactEvent:FireServer(ohString1, ohBoolean2, ohString3)
                                        end)
                                        task.wait(0.1)
                                end
                            end
                        end
                        
                        task.spawn(reviveAllPlayers)
                    end
                end
            end)
            
            featureStates.interactConnection = connection
            featureStates.interactHookActive = true
        end
    end
end

local function stopAutoRevive()
    if reviveLoopHandle then
        task.cancel(reviveLoopHandle)
        reviveLoopHandle = nil
    end
    
    if featureStates.interactHookActive then
        if featureStates.interactConnection then
            featureStates.interactConnection:Disconnect()
            featureStates.interactConnection = nil
        end
        featureStates.interactHookActive = false
    end
end

local function startFlying()
    if not character or not humanoid or not rootPart then return end
    flying = true
    bodyVelocity = Instance.new("BodyVelocity")
    bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    bodyVelocity.Velocity = Vector3.new(0, 0, 0)
    bodyVelocity.Parent = rootPart
    bodyGyro = Instance.new("BodyGyro")
    bodyGyro.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
    bodyGyro.CFrame = rootPart.CFrame
    bodyGyro.Parent = rootPart
    humanoid.PlatformStand = true
end

local function stopFlying()
    flying = false
    if bodyVelocity then
        bodyVelocity:Destroy()
        bodyVelocity = nil
    end
    if bodyGyro then
        bodyGyro:Destroy()
        bodyGyro = nil
    end
    if humanoid then
        humanoid.PlatformStand = false
    end
end

local function updateFly()
    if not flying or not bodyVelocity or not bodyGyro then return end
    local camera = workspace.CurrentCamera
    local cameraCFrame = camera.CFrame
    local direction = Vector3.new(0, 0, 0)
    local moveDirection = humanoid.MoveDirection
    if moveDirection.Magnitude > 0 then
        local forwardVector = cameraCFrame.LookVector
        local rightVector = cameraCFrame.RightVector
        local forwardComponent = moveDirection:Dot(forwardVector) * forwardVector
        local rightComponent = moveDirection:Dot(rightVector) * rightVector
        direction = direction + (forwardComponent + rightComponent).Unit * moveDirection.Magnitude
    end
    if UserInputService:IsKeyDown(Enum.KeyCode.Space) or humanoid.Jump then
        direction = direction + Vector3.new(0, 1, 0)
    end
    if UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) then
        direction = direction - Vector3.new(0, 1, 0)
    end
    bodyVelocity.Velocity = direction.Magnitude > 0 and direction.Unit * (featureStates.FlySpeed * 2) or Vector3.new(0, 0, 0)
    bodyGyro.CFrame = cameraCFrame
end

local function Tpwalking()
    if ToggleTpwalk and character and humanoid and rootPart then
        local moveDirection = humanoid.MoveDirection
        local moveDistance = featureStates.TpwalkValue
        local origin = rootPart.Position
        local direction = moveDirection * moveDistance
        local targetPosition = origin + direction
        local raycastParams = RaycastParams.new()
        raycastParams.FilterDescendantsInstances = {character}
        raycastParams.FilterType = Enum.RaycastFilterType.Exclude
        local raycastResult = workspace:Raycast(origin, direction, raycastParams)
        if raycastResult then
            local hitPosition = raycastResult.Position
            local distanceToHit = (hitPosition - origin).Magnitude
            if distanceToHit < math.abs(moveDistance) then
                targetPosition = origin + (direction.Unit * (distanceToHit - 0.1))
            end
        end
        rootPart.CFrame = CFrame.new(targetPosition) * rootPart.CFrame.Rotation
        rootPart.CanCollide = true
    end
end

local function startTpwalk()
    ToggleTpwalk = true
    if TpwalkConnection then
        TpwalkConnection:Disconnect()
    end
    TpwalkConnection = RunService.Heartbeat:Connect(Tpwalking)
end

local function stopTpwalk()
    ToggleTpwalk = false
    if TpwalkConnection then
        TpwalkConnection:Disconnect()
        TpwalkConnection = nil
    end
    if rootPart then
        rootPart.CanCollide = false
    end
end

local function setupJumpBoost()
    if not character or not humanoid then return end
    humanoid.StateChanged:Connect(function(oldState, newState)
        if newState == Enum.HumanoidStateType.Landed then
            jumpCount = 0
        end
    end)
    humanoid.Jumping:Connect(function(isJumping)
        if isJumping and featureStates.JumpBoost and jumpCount < MAX_JUMPS then
            jumpCount = jumpCount + 1
            humanoid.JumpHeight = featureStates.JumpPower
            if jumpCount > 1 then
                rootPart:ApplyImpulse(Vector3.new(0, featureStates.JumpPower * rootPart.Mass, 0))
            end
        end
    end)
end
if featureStates.CustomGravity then
    workspace.Gravity = featureStates.GravityValue
else
    workspace.Gravity = originalGameGravity
end
if not featureStates.GravityValue or type(featureStates.GravityValue) ~= "number" then
    featureStates.GravityValue = originalGameGravity
end
local function reapplyFeatures()
    if featureStates.Fly then
        if flying then stopFlying() end
        startFlying()
    end
end
if featureStates.AutoWhistle then
    stopAutoWhistle()
    startAutoWhistle()
end
local function startJumpBoost()
    if humanoid then
        humanoid.JumpPower = featureStates.JumpPower
    end
end

local function stopJumpBoost()
    jumpCount = 0
    if humanoid then
        humanoid.JumpPower = 50
    end
end

local function startAntiAFK()
    AntiAFKConnection = player.Idled:Connect(function()
        VirtualUser:Button2Down(Vector2.new(0,0), workspace.CurrentCamera.CFrame)
        task.wait(1)
        VirtualUser:Button2Up(Vector2.new(0,0), workspace.CurrentCamera.CFrame)
    end)
end

local function stopAntiAFK()
    if AntiAFKConnection then
        AntiAFKConnection:Disconnect()
        AntiAFKConnection = nil
    end
end

local function startAutoCarry()
    AutoCarryConnection = RunService.Heartbeat:Connect(function()
        if not featureStates.AutoCarry then return end
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if hrp then
            for _, other in ipairs(Players:GetPlayers()) do
                if other ~= player and other.Character and other.Character:FindFirstChild("HumanoidRootPart") then
                    local dist = (hrp.Position - other.Character.HumanoidRootPart.Position).Magnitude
                    if dist <= 20 then
                        local args = { "Carry", [3] = other.Name }
                        pcall(function()
                            game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("Character"):WaitForChild("Interact"):FireServer(unpack(args))
                        end)
                        task.wait(0.01)
                    end
                end
            end
        end
    end)
end

local function stopAutoCarry()
    if AutoCarryConnection then
        AutoCarryConnection:Disconnect()
        AutoCarryConnection = nil
    end
end

local function getServerLink()
    local placeId = game.PlaceId
    local jobId = game.JobId
    return string.format("https://www.roblox.com/games/start?placeId=%d&jobId=%s", placeId, jobId)
end

local function stopNoFog()
    Lighting.FogEnd = originalFogEnd
    for _, atmosphere in pairs(originalAtmospheres) do
        if not atmosphere.Parent then
            local newAtmosphere = Instance.new("Atmosphere")
            for _, prop in pairs({"Density", "Offset", "Color", "Decay", "Glare", "Haze"}) do
                if atmosphere[prop] then
                    newAtmosphere[prop] = atmosphere[prop]
                end
            end
            newAtmosphere.Parent = Lighting
        end
    end
end
local function fireVoteServer(mapNumber)
    local eventsFolder = ReplicatedStorage:WaitForChild("Events", 10)
    if eventsFolder then
        local playerFolder = eventsFolder:WaitForChild("Player", 10)
        if playerFolder then
            local voteEvent = playerFolder:WaitForChild("Vote", 10)
            if voteEvent and typeof(voteEvent) == "Instance" and voteEvent:IsA("RemoteEvent") then
                local args = {[1] = mapNumber}
                voteEvent:FireServer(unpack(args))
            end
        end
    end
end

local function startAutoVote()
    AutoVoteConnection = RunService.Heartbeat:Connect(function()
        fireVoteServer(featureStates.SelectedMap)
    end)
end

local function stopAutoVote()
    if AutoVoteConnection then
        AutoVoteConnection:Disconnect()
        AutoVoteConnection = nil
    end
end


local function startAutoWin()
    local securityPart = workspace:FindFirstChild("SecurityPart")
    if not securityPart then
        print("SecurityPart not found")
        return
    end
    
    AutoWinConnection = RunService.Heartbeat:Connect(function()
        if character and rootPart then
            if not character:GetAttribute("Downed") then
                rootPart.CFrame = securityPart.CFrame + Vector3.new(0, 3, 0)
            end
        end
    end)
end

local function stopAutoWin()
    if AutoWinConnection then
        AutoWinConnection:Disconnect()
        AutoWinConnection = nil
    end
end
local function startAutoMoneyFarm()
    local securityPart = workspace:FindFirstChild("SecurityPart")
    if not securityPart then
        print("SecurityPart not found")
        return
    end
    
    AutoMoneyFarmConnection = RunService.Heartbeat:Connect(function()
        if character and rootPart then
            local downedPlayerFound = false
            local playersInGame = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Players")
            if playersInGame then
                for _, v in pairs(playersInGame:GetChildren()) do
                    if v:IsA("Model") and v:GetAttribute("Downed") then
                        if v:FindFirstChild("RagdollConstraints") then
                            continue
                        end
                        
                        rootPart.CFrame = v.HumanoidRootPart.CFrame + Vector3.new(0, 3, 0)
                        ReplicatedStorage.Events.Character.Interact:FireServer("Revive", true, v)
                        task.wait(0.5)
                        downedPlayerFound = true
                        break
                    end
                end
            end
            
            if not downedPlayerFound then
                rootPart.CFrame = securityPart.CFrame + Vector3.new(0, 3, 0)
            end
        end
    end)
end

local function stopAutoMoneyFarm()
    if AutoMoneyFarmConnection then
        AutoMoneyFarmConnection:Disconnect()
        AutoMoneyFarmConnection = nil
    end
end
local autoWhistleHandle = nil

local function startAutoWhistle()
    if autoWhistleHandle then return end  
    autoWhistleHandle = task.spawn(function()
        while featureStates.AutoWhistle do
            pcall(function() 
                game:GetService("ReplicatedStorage").Events.Character.Whistle:FireServer()
            end)
            task.wait(1)
        end
    end)
end

local function stopAutoWhistle()
    featureStates.AutoWhistle = false
    if autoWhistleHandle then
        task.cancel(autoWhistleHandle)
        autoWhistleHandle = nil
    end
end
local function onCharacterAdded(newCharacter, plr)
    if plr == player then
        character = newCharacter
        humanoid = character:WaitForChild("Humanoid", 5)
        rootPart = character:WaitForChild("HumanoidRootPart", 5)
        if not humanoid or not rootPart then
            warn("Failed to find Humanoid or HumanoidRootPart")
            return
        end
        if type(setupJumpBoost) == "function" then
            setupJumpBoost()
        else
            warn("setupJumpBoost is not a function")
        end
        if type(reapplyFeatures) == "function" then
            reapplyFeatures()
        else
            warn("reapplyFeatures is not a function")
        end
    end
end
local function reapplyFeatures()
print("Test")
end
local function onPlayerAdded(plr)
    plr.CharacterAdded:Connect(function(newCharacter)
        onCharacterAdded(newCharacter, plr)
    end)
    if plr.Character then
        onCharacterAdded(plr.Character, plr)
    end
end

Players.PlayerAdded:Connect(onPlayerAdded)

for _, plr in ipairs(Players:GetPlayers()) do
    onPlayerAdded(plr)
end

UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if not gameProcessedEvent and input.KeyCode == Enum.KeyCode.Space then
        if featureStates.InfiniteJump then
            if featureStates.JumpMethod == "Hold" then
                isJumpHeld = true
                bouncePlayer()
                task.spawn(function()
                    while isJumpHeld and featureStates.InfiniteJump and featureStates.JumpMethod == "Hold" do
                        bouncePlayer()
                        task.wait(0.1)
                    end
                end)
            elseif featureStates.JumpMethod == "Spam" then
                if not isJumpHeld then
                    isJumpHeld = true
                    bouncePlayer()
                end
            end
        end
    end
end)

UserInputService.InputEnded:Connect(function(input, gameProcessedEvent)
    if not gameProcessedEvent and input.KeyCode == Enum.KeyCode.Space then
        isJumpHeld = false
    end
end)

local function setupMobileJumpButton()
    local success, result = pcall(function()
        local touchGui = player.PlayerGui:WaitForChild("TouchGui", 5)
        local touchControlFrame = touchGui:WaitForChild("TouchControlFrame", 5)
        local jumpButton = touchControlFrame:WaitForChild("JumpButton", 5)
        
        jumpButton.Activated:Connect(function()
            if featureStates.InfiniteJump then
                if featureStates.JumpMethod == "Spam" then
                    bouncePlayer()
                elseif featureStates.JumpMethod == "Hold" then
                    bouncePlayer()
                end
            end
        end)

        jumpButton.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.Touch then
                isJumpHeld = true
                if featureStates.InfiniteJump and featureStates.JumpMethod == "Hold" then
                    while isJumpHeld and featureStates.InfiniteJump and featureStates.JumpMethod == "Hold" do
                        bouncePlayer()
                        task.wait(0.1)
                    end
                end
            end
        end)

        jumpButton.InputEnded:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.Touch then
                isJumpHeld = false
            end
        end)
    end)
    if not success then
        warn("Failed to set up mobile jump button: " .. tostring(result))
    end
end

if player.Character then
    onCharacterAdded(player.Character, player)
else
    player.CharacterAdded:Connect(function(newCharacter)
        onCharacterAdded(newCharacter, player)
    end)
end

RunService.RenderStepped:Connect(updateFly)
local function setupGui()
local function getServers()
    local request = request({
        Url = "https://games.roblox.com/v1/games/" .. placeId .. "/servers/Public?sortOrder=Desc&limit=100",
        Method = "GET",
    })

    if request.StatusCode == 200 then
        local serverData = HttpService:JSONDecode(request.Body)
        local serverList = {}

        for _, server in pairs(serverData.data) do
            if server.id ~= jobId and server.playing < server.maxPlayers then
                local serverInfo = {
                    serverId = server.id or "N/A",
                    players = server.playing or 0,
                    maxPlayers = server.maxPlayers or 0,
                    ping = server.ping or "N/A",
                }
                table.insert(serverList, serverInfo)
            end
        end
        return serverList
    else
        return {}
    end
end

local function serverHop()

local AllIDs = {}
local foundAnything = ""
local actualHour = os.date("!*t").hour
local Deleted = false
local S_T = game:GetService("TeleportService")
local S_H = game:GetService("HttpService")

local File = pcall(function()
	AllIDs = S_H:JSONDecode(readfile("server-hop-temp.json"))
end)
if not File then
	table.insert(AllIDs, actualHour)
	pcall(function()
		writefile("server-hop-temp.json", S_H:JSONEncode(AllIDs))
	end)

end
local function TPReturner(placeId)
	local Site;
	if foundAnything == "" then
		Site = S_H:JSONDecode(game:HttpGet('https://games.roblox.com/v1/games/' .. placeId .. '/servers/Public?sortOrder=Asc&limit=100'))
	else
		Site = S_H:JSONDecode(game:HttpGet('https://games.roblox.com/v1/games/' .. placeId .. '/servers/Public?sortOrder=Asc&limit=100&cursor=' .. foundAnything))
	end
	local ID = ""
	if Site.nextPageCursor and Site.nextPageCursor ~= "null" and Site.nextPageCursor ~= nil then
		foundAnything = Site.nextPageCursor
	end
	local num = 0;
	for i,v in pairs(Site.data) do
		local Possible = true
		ID = tostring(v.id)
		if tonumber(v.maxPlayers) > tonumber(v.playing) then
			for _,Existing in pairs(AllIDs) do
				if num ~= 0 then
					if ID == tostring(Existing) then
						Possible = false
					end
				else
					if tonumber(actualHour) ~= tonumber(Existing) then
						local delFile = pcall(function()
							delfile("server-hop-temp.json")
							AllIDs = {}
							table.insert(AllIDs, actualHour)
						end)
					end
				end
				num = num + 1
			end
			if Possible == true then
				table.insert(AllIDs, ID)
				wait()
				pcall(function()
					writefile("server-hop-temp.json", S_H:JSONEncode(AllIDs))
					wait()
					S_T:TeleportToPlaceInstance(placeId, ID, game.Players.LocalPlayer)
				end)
				wait(4)
			end
		end
	end
end
local module = {}
function module:Teleport(placeId)
	while wait() do
		pcall(function()
			TPReturner(placeId)
			if foundAnything ~= "" then
				TPReturner(placeId)
			end
		end)
	end
end
module:Teleport(game.PlaceId)
return module
end


local function rejoinServer()
local Players = game:GetService("Players")
local TeleportService = game:GetService("TeleportService")

local player = Players.LocalPlayer

TeleportService:Teleport(game.PlaceId, player)
end

    local InfoSection = Window:Section({ Title = "loc:INFO", Opened = true })
    local FeatureSection = Window:Section({ Title = "loc:FEATURES", Opened = true })

    local Tabs = {
    infoYyyy = InfoSection:Tab({ Title = "Information", Icon = "info" }),
    Main = FeatureSection:Tab({ Title = "Main", Icon = "layout-grid" }),
    Player = FeatureSection:Tab({ Title = "loc:Player_TAB", Icon = "user" }),
    Auto = FeatureSection:Tab({ Title = "loc:AUTO_TAB", Icon = "repeat-2" }),
    Visuals = FeatureSection:Tab({ Title = "loc:VISUALS_TAB", Icon = "camera" }),
    ESP = FeatureSection:Tab({ Title = "loc:ESP_TAB", Icon = "eye" }),
    Utility = FeatureSection:Tab({ Title = "Utility", Icon = "wrench"}),
    Teleport = FeatureSection:Tab({ Title = "Teleport", Icon = "navigation" }),
    Settings = FeatureSection:Tab({ Title = "loc:SETTINGS_TAB", Icon = "settings" })
    
}

if not ui then ui = {} end
if not ui.Creator then ui.Creator = {} end

-- Define the Request function that mimics ui.Creator.Request
ui.Creator.Request = function(requestData)
    local HttpService = game:GetService("HttpService")
    
    -- Try different HTTP methods
    local success, result = pcall(function()
        if HttpService.RequestAsync then
            -- Method 1: Use RequestAsync if available
            local response = HttpService:RequestAsync({
                Url = requestData.Url,
                Method = requestData.Method or "GET",
                Headers = requestData.Headers or {}
            })
            return {
                Body = response.Body,
                StatusCode = response.StatusCode,
                Success = response.Success
            }
        else
            -- Method 2: Fallback to GetAsync
            local body = HttpService:GetAsync(requestData.Url)
            return {
                Body = body,
                StatusCode = 200,
                Success = true
            }
        end
    end)
    
    if success then
        return result
    else
        error("HTTP Request failed: " .. tostring(result))
    end
end

-- Remove this line completely: Info = InfoTab
-- The Info variable is already correctly set above

local InviteCode = "jWNDPNMmyB"
local DiscordAPI = "https://discord.com/api/v10/invites/" .. InviteCode .. "?with_counts=true&with_expiration=true"

local function LoadDiscordInfo()
    local success, result = pcall(function()
        return game:GetService("HttpService"):JSONDecode(ui.Creator.Request({
            Url = DiscordAPI,
            Method = "GET",
            Headers = {
                ["User-Agent"] = "RobloxBot/1.0",
                ["Accept"] = "application/json"
            }
        }).Body)
    end)

    if success and result and result.guild then
        local DiscordInfo = Tabs.infoYyyy:Paragraph({
            Title = result.guild.name,
            Desc = ' <font color="#52525b"></font> Member Count : ' .. tostring(result.approximate_member_count) ..
                '\n <font color="#16a34a"></font> Online Count : ' .. tostring(result.approximate_presence_count),
            Image = "https://cdn.discordapp.com/icons/" .. result.guild.id .. "/" .. result.guild.icon .. ".png?size=1024",
            ImageSize = 42,
        })

        Tabs.infoYyyy:Button({
            Title = "Update Info",
            Callback = function()
                local updated, updatedResult = pcall(function()
                    return game:GetService("HttpService"):JSONDecode(ui.Creator.Request({
                        Url = DiscordAPI,
                        Method = "GET",
                    }).Body)
                end)

                if updated and updatedResult and updatedResult.guild then
                    DiscordInfo:SetDesc(
                        ' <font color="#52525b"></font> Member Count : ' .. tostring(updatedResult.approximate_member_count) ..
                        '\n <font color="#16a34a"></font> Online Count : ' .. tostring(updatedResult.approximate_presence_count)
                    )
                    
                    WindUI:Notify({
                        Title = "Discord Info Updated",
                        Content = "Successfully refreshed Discord statistics",
                        Duration = 2,
                        Icon = "refresh-cw",
                    })
                else
                    WindUI:Notify({
                        Title = "Update Failed",
                        Content = "Could not refresh Discord info",
                        Duration = 3,
                        Icon = "alert-triangle",
                    })
                end
            end
        })

        Tabs.infoYyyy:Button({
            Title = "Copy Discord Invite",
            Callback = function()
                setclipboard("https://discord.gg/" .. InviteCode)
                WindUI:Notify({
                    Title = "Copied!",
                    Content = "Discord invite copied to clipboard",
                    Duration = 2,
                    Icon = "clipboard-check",
                })
            end
        })
    else
        Tabs.infoYyyy:Paragraph({
            Title = "Error fetching Discord Info",
            Desc = "Unable to load Discord information. Check your internet connection.",
            Image = "triangle-alert",
            ImageSize = 26,
            Color = "Red",
        })
        print("Discord API Error:", result) -- Debug print
    end
end

LoadDiscordInfo()

Tabs.infoYyyy:Divider()
Tabs.infoYyyy:Section({ 
    Title = "DYHUB Information",
    TextXAlignment = "Center",
    TextSize = 17,
})
Tabs.infoYyyy:Divider()

Tabs.infoYyyy:Paragraph({
    Title = "Main Owner",
    Desc = "@dyumraisgoodguy#8888",
    Image = "rbxassetid://119789418015420",
    ImageSize = 30,
    Thumbnail = "",
    ThumbnailSize = 0,
    Locked = false,
})

Tabs.infoYyyy:Paragraph({
    Title = "Social",
    Desc = "Copy link social media for follow!",
    Image = "rbxassetid://104487529937663",
    ImageSize = 30,
    Thumbnail = "",
    ThumbnailSize = 0,
    Locked = false,
    Buttons = {
        {
            Icon = "copy",
            Title = "Copy Link",
            Callback = function()
                setclipboard("https://guns.lol/DYHUB")
                print("Copied social media link to clipboard!")
            end,
        }
    }
})

Tabs.infoYyyy:Paragraph({
    Title = "Discord",
    Desc = "Join our discord for more scripts!",
    Image = "rbxassetid://104487529937663",
    ImageSize = 30,
    Thumbnail = "",
    ThumbnailSize = 0,
    Locked = false,
    Buttons = {
        {
            Icon = "copy",
            Title = "Copy Link",
            Callback = function()
                setclipboard("https://discord.gg/jWNDPNMmyB")
                print("Copied discord link to clipboard!")
            end,
        }
    }
})


-- Main Tab
Tabs.Main:Section({ Title = "Server Info", TextSize = 20 })
Tabs.Main:Divider()

local placeName = "Unknown"
local success, productInfo = pcall(function()
    return MarketplaceService:GetProductInfo(placeId)
end)
if success and productInfo then
    placeName = productInfo.Name
end

Tabs.Main:Paragraph({
    Title = "Game Mode",
    Desc = placeName
})

Tabs.Main:Button({
    Title = "Copy Server Link",
    Desc = "Copy the current server's join link",
    Icon = "link",
    Callback = function()
        local serverLink = getServerLink()
        pcall(function()
            setclipboard(serverLink)
        end)
        WindUI:Notify({
                Icon = "link",
                Title = "Link Copied",
                Content = "The server invite link has been copied to your clipborad",
                Duration = 3
        })
    end
})

local numPlayers = #Players:GetPlayers()
local maxPlayers = Players.MaxPlayers

Tabs.Main:Paragraph({
    Title = "Current Players",
    Desc = numPlayers .. " / " .. maxPlayers
})

Tabs.Main:Paragraph({
    Title = "Server ID",
    Desc = jobId
})

Tabs.Main:Paragraph({
    Title = "Place ID",
    Desc = tostring(placeId)
})

Tabs.Main:Section({ Title = "Server Tools", TextSize = 20 })
Tabs.Main:Divider()

Tabs.Main:Button({
    Title = "Rejoin",
    Desc = "Rejoin the current server",
    Icon = "refresh-cw",
    Callback = function()
        rejoinServer()
    end
})

Tabs.Main:Button({
    Title = "Server Hop",
    Desc = "Hop to a random server",
    Icon = "shuffle",
    Callback = function()
        serverHop()
    end
})

Tabs.Main:Button({
    Title = "Hop to Small Server",
    Desc = "Hop to the smallest available server",
    Icon = "minimize",
    Callback = function()
        hopToSmallServer()
    end
})

Tabs.Main:Button({
       Title = "Advanced Server Hop",
       Desc = "Finding a Server inside your game",
       Icon = "server",
       Callback = function()
           local success, result = pcall(function()
               local script = loadstring(game:HttpGet("https://raw.githubusercontent.com/Pnsdgsa/Script-kids/refs/heads/main/Advanced%20Server%20Hop.lua"))()
           end)
           if not success then
               WindUI:Notify({
                   Title = "Error",
                   Content = "Oopsie Daisy Some thing wrong happening with the Github Repository link, Unfortunately this script no longer exsit: " .. tostring(result),
                   Duration = 4
               })
           else
               WindUI:Notify({
                   Title = "Success",
                   Content = "Script Is Loaded",
                   Duration = 3
               })
           end
       end
   })
   Tabs.Main:Section({ Title = "Misc", TextSize = 20 })
   Tabs.Main:Divider()

ResetWhenTakeDamageToggle = Tabs.Main:Toggle({
    Title = "Reset when take damage",
    Value = featureStates.ResetWhenTakeDamage,
    Callback = function(value)
        featureStates.ResetWhenTakeDamage = value
    end
})

ResetDamageTypeDropdown = Tabs.Main:Dropdown({
    Title = "Reset damage types",
    Values = {"Any Damage", "Low Health"},
    Value = featureStates.ResetDamageType,
    Callback = function(value)
        featureStates.ResetDamageType = value
    end
})
   Tabs.Main:Button({
    Title = "Show/Hide Reload button",
    Desc = "This button allow you to use front view mode without keyboard or any tool in vip server",
    Icon = "switch-camera",
    Callback = function()
        if reloadVisible then
            if reloadButton then
                reloadButton.Visible = false
                reloadButton.Active = false
            end
            reloadVisible = false
        else
            reloadButton = game:GetService("Players").LocalPlayer.PlayerGui.Shared.HUD.Mobile.Right.Mobile.ReloadButton
            local originalParent = reloadButton.Parent
            reloadButton.Parent = nil
            wait()
            reloadButton.Parent = originalParent
            reloadButton.Visible = true
            reloadButton.Active = true
            reloadVisible = true
        end
    end
})
       AntiAFKToggle = Tabs.Main:Toggle({
        Title = "loc:ANTI_AFK",
        Value = false,
        Callback = function(state)
            featureStates.AntiAFK = state
            if state then
                startAntiAFK()
            else
                stopAntiAFK()
            end
        end
    })
    local PathfindingService = game:GetService("PathfindingService")

featureStates.AntiNextbot = false
featureStates.AntiNextbotTeleportType = "Distance"
featureStates.AntiNextbotDistance = 50
featureStates.DistanceTeleport = 20

local function handleAntiNextbot()
    if not featureStates.AntiNextbot then return end

    local character = Players.LocalPlayer.Character
    local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return end

    local nextbots = {}
    local npcsFolder = workspace:FindFirstChild("NPCs")
    if npcsFolder then
        for _, model in ipairs(npcsFolder:GetChildren()) do
            if model:IsA("Model") and isNextbotModel(model) then
                local hrp = model:FindFirstChild("HumanoidRootPart")
                if hrp then
                    table.insert(nextbots, model)
                end
            end
        end
    end

    local playersFolder = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Players")
    if playersFolder then
        for _, model in ipairs(playersFolder:GetChildren()) do
            if model:IsA("Model") and isNextbotModel(model) then
                local hrp = model:FindFirstChild("HumanoidRootPart")
                if hrp then
                    table.insert(nextbots, model)
                end
            end
        end
    end

    for _, nextbot in ipairs(nextbots) do
        local nextbotHrp = nextbot:FindFirstChild("HumanoidRootPart")
        if nextbotHrp then
            local distance = (humanoidRootPart.Position - nextbotHrp.Position).Magnitude
            if distance <= featureStates.AntiNextbotDistance then
                if featureStates.AntiNextbotTeleportType == "Players" then
                    local validPlayers = {}
                    for _, plr in ipairs(Players:GetPlayers()) do
                        if plr ~= player and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                            table.insert(validPlayers, plr)
                        end
                    end
                    if #validPlayers > 0 then
                        local randomPlayer = validPlayers[math.random(1, #validPlayers)]
                        humanoidRootPart.CFrame = randomPlayer.Character.HumanoidRootPart.CFrame + Vector3.new(0, 3, 0)
                    end
                elseif featureStates.AntiNextbotTeleportType == "Spawn" then
                    local spawnsFolder = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Map") and workspace.Game.Map:FindFirstChild("Parts") and workspace.Game.Map.Parts:FindFirstChild("Spawns")
                    if spawnsFolder then
                        local spawnLocations = spawnsFolder:GetChildren()
                        if #spawnLocations > 0 then
                            local randomSpawn = spawnLocations[math.random(1, #spawnLocations)]
                            humanoidRootPart.CFrame = randomSpawn.CFrame + Vector3.new(0, 3, 0)
                        end
                    end
                elseif featureStates.AntiNextbotTeleportType == "Distance" then
                    local direction = (humanoidRootPart.Position - nextbotHrp.Position).Unit
                    local targetPos = humanoidRootPart.Position + direction * featureStates.DistanceTeleport

                    local path = PathfindingService:CreatePath({
                        AgentRadius = 2,
                        AgentHeight = 5,
                        AgentCanJump = true
                    })

                    local success, errorMessage = pcall(function()
                        path:ComputeAsync(humanoidRootPart.Position, targetPos)
                    end)

                    if success and path.Status == Enum.PathStatus.Success then
                        local waypoints = path:GetWaypoints()
                        if #waypoints > 1 then
                            local lastValidPos = waypoints[#waypoints].Position
                            local distanceToTarget = (lastValidPos - humanoidRootPart.Position).Magnitude
                            if distanceToTarget <= featureStates.DistanceTeleport then
                                humanoidRootPart.CFrame = CFrame.new(lastValidPos + Vector3.new(0, 3, 0))
                            else
                                for i = #waypoints, 1, -1 do
                                    local waypointPos = waypoints[i].Position
                                    if (waypointPos - humanoidRootPart.Position).Magnitude <= featureStates.DistanceTeleport then
                                        humanoidRootPart.CFrame = CFrame.new(waypointPos + Vector3.new(0, 3, 0))
                                        break
                                    end
                                end
                            end
                        end
                    else
                        local fallbackPos = humanoidRootPart.Position + direction * featureStates.DistanceTeleport
                        local ray = Ray.new(humanoidRootPart.Position, direction * featureStates.DistanceTeleport)
                        local hit, hitPos = workspace:FindPartOnRayWithIgnoreList(ray, {character, nextbot})
                        if not hit then
                            humanoidRootPart.CFrame = CFrame.new(fallbackPos + Vector3.new(0, 3, 0))
                        else
                            humanoidRootPart.CFrame = CFrame.new(hitPos + Vector3.new(0, 3, 0))
                        end
                    end
                end
                break
            end
        end
    end
end

task.spawn(function()
    while true do
        if featureStates.AntiNextbot then
            pcall(handleAntiNextbot)
        end
        task.wait(0.1)
    end
end)


 AntiNextbotToggle = Tabs.Main:Toggle({
    Title = "Anti-Nextbot",
    Desc = "Automatically teleport away from nearby Nextbots (farms pause if too close)",
    Icon = "shield",
    Value = featureStates.AntiNextbot,
    Callback = function(state)
        featureStates.AntiNextbot = state
        
        if state then
            antiNextbotConnection = game:GetService("RunService").Heartbeat:Connect(function()
                if not featureStates.AntiNextbot then return end
                
                local character = player.Character
                local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
                if not humanoidRootPart then return end
                local nearestDistance = math.huge
                local nearestNextbot = nil
                local playersFolder = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Players")
                local npcsFolder = workspace:FindFirstChild("NPCs")
                
                if playersFolder then
                    for _, model in pairs(playersFolder:GetChildren()) do
                        if model:IsA("Model") and model:FindFirstChild("HumanoidRootPart") and isNextbotModel(model) then
                            local dist = (model.HumanoidRootPart.Position - humanoidRootPart.Position).Magnitude
                            if dist < nearestDistance then
                                nearestDistance = dist
                                nearestNextbot = model
                            end
                        end
                    end
                end
                
                if npcsFolder then
                    for _, model in pairs(npcsFolder:GetChildren()) do
                        if model:IsA("Model") and model:FindFirstChild("HumanoidRootPart") and isNextbotModel(model) then
                            local dist = (model.HumanoidRootPart.Position - humanoidRootPart.Position).Magnitude
                            if dist < nearestDistance then
                                nearestDistance = dist
                                nearestNextbot = model
                            end
                        end
                    end
                end
                
                local threshold = featureStates.AntiNextbotDistance
                local isTooClose = (nearestDistance < threshold)
                
                if isTooClose and not farmsSuppressedByAntiNextbot then
                    previousMoneyFarm = getgenv().moneyfarm
                    previousTicketFarm = getgenv().ticketfarm
                    previousAutoWin = getgenv().autowin
                    
                    getgenv().moneyfarm = false
                    getgenv().ticketfarm = false
                    getgenv().autowin = false
                    
                    stopAutoMoneyFarm()
                    stopAutoWin()
                    
                    if AutoMoneyFarmToggle and AutoMoneyFarmToggle.Set then AutoMoneyFarmToggle:Set(false) end
                    if AutoTicketFarmToggle and AutoTicketFarmToggle.Set then AutoTicketFarmToggle:Set(false) end
                    if AutoWinToggle and AutoWinToggle.Set then AutoWinToggle:Set(false) end
                    
                    farmsSuppressedByAntiNextbot = true
                elseif not isTooClose and farmsSuppressedByAntiNextbot then
                    getgenv().moneyfarm = previousMoneyFarm
                    getgenv().ticketfarm = previousTicketFarm
                    getgenv().autowin = previousAutoWin
                    
                    if previousMoneyFarm then
                        startAutoMoneyFarm()
                        if AutoMoneyFarmToggle and AutoMoneyFarmToggle.Set then AutoMoneyFarmToggle:Set(true) end
                    end
                    if previousTicketFarm then
                        if AutoTicketFarmToggle and AutoTicketFarmToggle.Set then AutoTicketFarmToggle:Set(true) end
                    end
                    if previousAutoWin then
                        startAutoWin()
                        if AutoWinToggle and AutoWinToggle.Set then AutoWinToggle:Set(true) end
                    end
                    
                    farmsSuppressedByAntiNextbot = false
                end
                
                if isTooClose then
                    local safePart = workspace:FindFirstChild("SecurityPart")
                    if safePart then
                        humanoidRootPart.CFrame = safePart.CFrame + Vector3.new(math.random(-5, 5), 3, math.random(-5, 5))
                    end
                end
            end)
        else
            if antiNextbotConnection then
                antiNextbotConnection:Disconnect()
                antiNextbotConnection = nil
            end
            if farmsSuppressedByAntiNextbot then
                getgenv().moneyfarm = previousMoneyFarm
                getgenv().ticketfarm = previousTicketFarm
                getgenv().autowin = previousAutoWin
                
                if previousMoneyFarm then
                    startAutoMoneyFarm()
                    if AutoMoneyFarmToggle and AutoMoneyFarmToggle.Set then AutoMoneyFarmToggle:Set(true) end
                end
                if previousTicketFarm then
                    if AutoTicketFarmToggle and AutoTicketFarmToggle.Set then AutoTicketFarmToggle:Set(true) end
                end
                if previousAutoWin then
                    startAutoWin()
                    if AutoWinToggle and AutoWinToggle.Set then AutoWinToggle:Set(true) end
                end
                
                farmsSuppressedByAntiNextbot = false
            end
        end
    end
})

 AntiNextbotTeleportTypeDropdown = Tabs.Main:Dropdown({
    Title = "Anti-Nextbot Teleport Type",
    Desc = "Choose how to teleport when avoiding Nextbots",
    Values = {"Players", "Spawn", "Distance"},
    Value = featureStates.AntiNextbotTeleportType,
    Callback = function(value)
        featureStates.AntiNextbotTeleportType = value
    end
})

 AntiNextbotDistanceInput = Tabs.Main:Input({
    Title = "Anti-Nextbot Distance",
    Desc = "Distance threshold for Nextbot detection",
    Placeholder = tostring(featureStates.AntiNextbotDistance),
    NumbersOnly = true,
    Value = tostring(featureStates.AntiNextbotDistance),
    Callback = function(value)
        local num = tonumber(value)
        if num and num > 0 then
            featureStates.AntiNextbotDistance = num
        end
    end
})
 DistanceTeleportInput = Tabs.Main:Input({
    Title = "Distance Teleport",
    Desc = "How far to teleport when using Distance mode",
    Placeholder = tostring(featureStates.DistanceTeleport),
    NumbersOnly = true,
    Callback = function(value)
        local num = tonumber(value)
        if num and num > 0 then
            featureStates.DistanceTeleport = num
        end
    end
})

featureStates.AntiNextbotSpawn = false
featureStates.AntiNextbotSpawnType = "Spawn"
featureStates.AntiNextbotSpawnDistance = 40
featureStates.AntiNextbotTeleportDistance = 20

local cachedAttachment = nil
local lastAttachmentCheck = 0
local attachmentCheckCooldown = 5
local isSearchingForAttachment = false

local function getAttachment()
    if tick() - lastAttachmentCheck > attachmentCheckCooldown then
        cachedAttachment = workspace.Terrain:FindFirstChild("NextbotSpawnAttachment")
        lastAttachmentCheck = tick()
    end
    return cachedAttachment
end

local function startAttachmentSearch()
    if isSearchingForAttachment then return end
    isSearchingForAttachment = true
    
    task.spawn(function()
        while featureStates.AntiNextbotSpawn and not getAttachment() do
            task.wait(3)
            
            local statsFolder = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Stats")
            if statsFolder then
                local timerValue = statsFolder:GetAttribute("Timer")
                if timerValue == 0 then
                    cachedAttachment = workspace.Terrain:FindFirstChild("NextbotSpawnAttachment")
                    lastAttachmentCheck = tick()
                    if cachedAttachment then
                        WindUI:Notify({
                            Title = "Anti Nextbot Spawn",
                            Content = "Attachment found! System now active.",
                            Duration = 3
                        })
                        break
                    end
                end
            end
        end
        isSearchingForAttachment = false
    end)
end

local function fastDistanceSquared(pos1, pos2)
    local dx = pos1.X - pos2.X
    local dy = pos1.Y - pos2.Y
    local dz = pos1.Z - pos2.Z
    return dx*dx + dy*dy + dz*dz
end

local function findSafeTeleportPositionReverse(startPos, targetPos)
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.FilterDescendantsInstances = {player.Character}
    
    local direction = (targetPos - startPos).Unit
    local maxDistance = (targetPos - startPos).Magnitude
    
    for distance = maxDistance, 0, -5 do
        local testPos = startPos + (direction * distance)
        
        local downRay = workspace:Raycast(testPos + Vector3.new(0, 10, 0), Vector3.new(0, -20, 0), raycastParams)
        if downRay then
            local groundPos = downRay.Position + Vector3.new(0, 3, 0)
            
            local upRay = workspace:Raycast(groundPos, Vector3.new(0, 6, 0), raycastParams)
            if not upRay then
                local sideRays = {
                    Vector3.new(3, 0, 0),
                    Vector3.new(-3, 0, 0),
                    Vector3.new(0, 0, 3),
                    Vector3.new(0, 0, -3)
                }
                
                local isSafe = true
                for _, sideDir in ipairs(sideRays) do
                    local sideRay = workspace:Raycast(groundPos, sideDir, raycastParams)
                    if sideRay and sideRay.Instance.CanCollide then
                        isSafe = false
                        break
                    end
                end
                
                if isSafe then
                    return groundPos
                end
            end
        end
    end
    
    return nil
end

local function teleportToSpawn()
    local spawnsFolder = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Map") and workspace.Game.Map:FindFirstChild("Parts") and workspace.Game.Map.Parts:FindFirstChild("Spawns")
    
    if spawnsFolder then
        local spawnLocations = spawnsFolder:GetChildren()
        if #spawnLocations > 0 then
            local character = player.Character
            local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
            
            if humanoidRootPart then
                for i = 1, math.min(3, #spawnLocations) do
                    local randomSpawn = spawnLocations[math.random(1, #spawnLocations)]
                    local targetPosition = randomSpawn.CFrame.Position + Vector3.new(0, 3, 0)
                    
                    local safePosition = findSafeTeleportPositionReverse(humanoidRootPart.Position, targetPosition)
                    if safePosition then
                        humanoidRootPart.CFrame = CFrame.new(safePosition)
                        return true
                    end
                end
            end
        end
    end
    return false
end

local function teleportToPlayer()
    local players = Players:GetPlayers()
    local validPlayers = {}
    
    for _, plr in ipairs(players) do
        if plr ~= player and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
            table.insert(validPlayers, plr)
        end
    end
    
    if #validPlayers > 0 then
        local character = player.Character
        local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
        
        if humanoidRootPart then
            for i = 1, math.min(3, #validPlayers) do
                local randomPlayer = validPlayers[math.random(1, #validPlayers)]
                local targetPosition = randomPlayer.Character.HumanoidRootPart.Position + Vector3.new(0, 3, 0)
                
                local safePosition = findSafeTeleportPositionReverse(humanoidRootPart.Position, targetPosition)
                if safePosition then
                    humanoidRootPart.CFrame = CFrame.new(safePosition)
                    return true
                end
            end
        end
    end
    return false
end

local function teleportToDistance()
    local attachment = getAttachment()
    local character = player.Character
    local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return false end
    
    if attachment then
        local direction = (humanoidRootPart.Position - attachment.WorldPosition).Unit
        local targetPos = humanoidRootPart.Position + direction * featureStates.AntiNextbotTeleportDistance
        
        local safePosition = findSafeTeleportPositionReverse(humanoidRootPart.Position, targetPos)
        if safePosition then
            humanoidRootPart.CFrame = CFrame.new(safePosition)
            return true
        else
            return teleportToSpawn()
        end
    else
        return teleportToSpawn()
    end
end

local function isPlayerNearSpawn()
    local attachment = getAttachment()
    if not attachment or not player.Character then return false end
    
    local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return false end
    
    local distanceSquared = fastDistanceSquared(humanoidRootPart.Position, attachment.WorldPosition)
    local triggerDistanceSquared = featureStates.AntiNextbotSpawnDistance * featureStates.AntiNextbotSpawnDistance
    
    return distanceSquared <= triggerDistanceSquared
end

local function performAvoidance()
    if not player.Character then return end
    
    local success = false
    
    if featureStates.AntiNextbotSpawnType == "Spawn" then
        success = teleportToSpawn()
    elseif featureStates.AntiNextbotSpawnType == "Player" then
        success = teleportToPlayer()
    else
        success = teleportToDistance()
    end
    
    if not success then
        WindUI:Notify({
            Title = "Anti Nextbot Spawn",
            Content = "No safe teleport location found!",
            Duration = 2
        })
    end
end

local nextbotSpawnConnection = nil
local lastAvoidanceTime = 0
local avoidanceCooldown = 2

local function startAntiNextbot()
    if nextbotSpawnConnection then
        nextbotSpawnConnection:Disconnect()
    end
    
    nextbotSpawnConnection = RunService.Heartbeat:Connect(function()
        if not featureStates.AntiNextbotSpawn or not player.Character then return end
        
        if tick() - lastAvoidanceTime < avoidanceCooldown then return end
        
        local attachment = getAttachment()
        if not attachment then
            return
        end
        
        if isPlayerNearSpawn() then
            performAvoidance()
            lastAvoidanceTime = tick()
        end
    end)
end

local function restartSystemOnEvents()
    player.CharacterAdded:Connect(function()
        if featureStates.AntiNextbotSpawn then
            task.wait(1)
            if not nextbotSpawnConnection then
                startAntiNextbot()
            end
        end
    end)
    
    local statsFolder = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Stats")
    if statsFolder then
        statsFolder:GetAttributeChangedSignal("Timer"):Connect(function()
            if featureStates.AntiNextbotSpawn then
                local timerValue = statsFolder:GetAttribute("Timer")
                if timerValue == 0 then
                    cachedAttachment = workspace.Terrain:FindFirstChild("NextbotSpawnAttachment")
                    lastAttachmentCheck = tick()
                    
                    if not nextbotSpawnConnection then
                        task.wait(1)
                        startAntiNextbot()
                    end
                end
            end
        end)
    end
end

AntiNextbotSpawnToggle = Tabs.Main:Toggle({
    Title = "Anti Nextbot Spawn",
    Desc = "Automatically avoid Nextbot spawn areas",
    Value = false,
    Callback = function(state)
        featureStates.AntiNextbotSpawn = state
        
        if state then
            startAntiNextbot()
            startAttachmentSearch()
            
            if not getAttachment() then
                WindUI:Notify({
                    Title = "Anti Nextbot Spawn",
                    Content = "System enabled - Searching for attachment...",
                    Duration = 3
                })
            else
                WindUI:Notify({
                    Title = "Anti Nextbot Spawn",
                    Content = "System enabled - Attachment found!",
                    Duration = 3
                })
            end
        else
            if nextbotSpawnConnection then
                nextbotSpawnConnection:Disconnect()
                nextbotSpawnConnection = nil
            end
            isSearchingForAttachment = false
        end
    end
})

AntiNextbotSpawnTypeDropdown = Tabs.Main:Dropdown({
    Title = "Avoidance Mode",
    Desc = "Choose how to avoid Nextbot spawn",
    Values = {"Spawn", "Player", "Distance"},
    Value = "Spawn",
    Callback = function(value)
        featureStates.AntiNextbotSpawnType = value
    end
})

AntiNextbotSpawnDistanceInput = Tabs.Main:Input({
    Title = "Avoidance Distance",
    Desc = "Distance to trigger avoidance (studs)",
    Placeholder = "40",
    NumbersOnly = true,
    Callback = function(value)
        local distance = tonumber(value)
        if distance and distance > 0 then
            featureStates.AntiNextbotSpawnDistance = distance
        end
    end
})

AntiNextbotTeleportDistanceInput = Tabs.Main:Input({
    Title = "Teleport Distance",
    Desc = "How far to teleport in Distance mode (studs)",
    Placeholder = "20",
    NumbersOnly = true,
    Callback = function(value)
        local distance = tonumber(value)
        if distance and distance > 0 then
            featureStates.AntiNextbotTeleportDistance = distance
        end
    end
})

task.spawn(function()
    while true do
        task.wait(attachmentCheckCooldown)
        
        if featureStates.AntiNextbotSpawn then
            local currentAttachment = workspace.Terrain:FindFirstChild("NextbotSpawnAttachment")
            
            if currentAttachment and not cachedAttachment then
                cachedAttachment = currentAttachment
                WindUI:Notify({
                    Title = "Anti Nextbot Spawn",
                    Content = "Attachment found! System now active.",
                    Duration = 3
                })
            elseif not currentAttachment and cachedAttachment then
                cachedAttachment = nil
                WindUI:Notify({
                    Title = "Anti Nextbot Spawn",
                    Content = "Attachment lost - System will reactivate when found.",
                    Duration = 3
                })
            else
                cachedAttachment = currentAttachment
            end
        end
    end
end)

restartSystemOnEvents()

local isMobile = UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled

Tabs.Main:Section({ Title = "Emote Crouch", TextSize = 20 })
Tabs.Main:Divider()

math.randomseed(tick())

local emoteInputs = {}
for i = 1, 12 do
    emoteInputs[i] = Tabs.Main:Input({
        Title = "Emote " .. i,
        Placeholder = "Emote Name Here",
        Callback = function(value)
            featureStates["Emote" .. i] = value
        end
    })
end

local emoteGui = nil
local emoteGuiButton = nil
local emoteInputConnection = nil
local emoteGuiVisible = false

local function makeDraggable(frame)
    frame.Active = true
    frame.Draggable = true
    pcall(function()
        local dragDetector = Instance.new("UIDragDetector")
        dragDetector.Parent = frame
    end)
    local originalBackground = frame.BackgroundColor3
    local originalTransparency = frame.BackgroundTransparency
    frame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            frame.BackgroundTransparency = originalTransparency - 0.1
        end
    end)
    frame.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            frame.BackgroundTransparency = originalTransparency
        end
    end)
end

local function triggerRandomEmote()
    local validEmotes = {}
    for i = 1, 12 do
        local emoteName = featureStates["Emote" .. i]
        if emoteName and emoteName ~= "" then
            table.insert(validEmotes, emoteName)
        end
    end
    
    if #validEmotes > 0 then
        math.randomseed(tick() + #validEmotes)
        
        local ohTable1 = { ["Key"] = "Crouch", ["Down"] = true }
        pcall(function()
            player.PlayerScripts.Events.temporary_events.UseKeybind:Fire(ohTable1)
        end)
        local randomIndex = math.random(1, #validEmotes)
        local randomEmote = validEmotes[randomIndex]
        pcall(function()
            ReplicatedStorage.Events.Character.Emote:FireServer(randomEmote)
        end)
    end
end

local function createEmoteGui(yOffset)
    local emoteGuiOld = playerGui:FindFirstChild("EmoteGui")
    if emoteGuiOld then emoteGuiOld:Destroy() end
    emoteGui = Instance.new("ScreenGui")
    emoteGui.Name = "EmoteGui"
    emoteGui.IgnoreGuiInset = true
    emoteGui.ResetOnSpawn = false
    emoteGui.Enabled = emoteGuiVisible and isMobile
    emoteGui.Parent = playerGui
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 60, 0, 60)
    frame.Position = UDim2.new(0.5, -30, 0.12 + (yOffset or 0), 0)
    frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    frame.BackgroundTransparency = 0.35
    frame.BorderSizePixel = 0
    frame.Parent = emoteGui
    makeDraggable(frame)
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 6)
    corner.Parent = frame
    local stroke = Instance.new("UIStroke")
    stroke.Color = Color3.fromRGB(150, 150, 150)
    stroke.Thickness = 2
    stroke.Parent = frame
    local label = Instance.new("TextLabel")
    label.Text = "Emote Crouch"
    label.Size = UDim2.new(0.9, 0, 0.5, 0)
    label.Position = UDim2.new(0.05, 0, 0, 0)
    label.BackgroundTransparency = 1
    label.TextColor3 = Color3.fromRGB(255, 255, 255)
    label.Font = Enum.Font.Roboto
    label.TextSize = 16
    label.TextXAlignment = Enum.TextXAlignment.Center
    label.TextYAlignment = Enum.TextYAlignment.Center
    label.TextScaled = true
    label.Parent = frame
    emoteGuiButton = Instance.new("TextButton")
    emoteGuiButton.Name = "TriggerButton"
    emoteGuiButton.Text = "Start"
    emoteGuiButton.Size = UDim2.new(0.9, 0, 0.5, 0)
    emoteGuiButton.Position = UDim2.new(0.05, 0, 0.5, 0)
    emoteGuiButton.BackgroundColor3 = Color3.fromRGB(0, 120, 80)
    emoteGuiButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    emoteGuiButton.Font = Enum.Font.Roboto
    emoteGuiButton.TextSize = 14
    emoteGuiButton.TextXAlignment = Enum.TextXAlignment.Center
    emoteGuiButton.TextYAlignment = Enum.TextYAlignment.Center
    emoteGuiButton.TextScaled = true
    emoteGuiButton.Parent = frame
    local buttonCorner = Instance.new("UICorner")
    buttonCorner.CornerRadius = UDim.new(0, 4)
    buttonCorner.Parent = emoteGuiButton
    emoteGuiButton.MouseButton1Click:Connect(function()
        triggerRandomEmote()
    end)
end

EmoteGUIToggle = Tabs.Main:Toggle({
    Title = "Emote Crouch",
    Desc = "Press J keybind if you have keyboard, Only type emote name without space and inside your emote slot will work",
    Value = false,
    Callback = function(state)
        emoteGuiVisible = state
        if state then
            if emoteInputConnection then
                emoteInputConnection:Disconnect()
            end
            spawn(function()
                emoteInputConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
                    if gameProcessed then return end
                    if input.KeyCode == Enum.KeyCode.J then
                        triggerRandomEmote()
                    end
                end)
            end)
            
            if isMobile and not emoteGui then
                createEmoteGui(0)
            elseif emoteGui then
                emoteGui.Enabled = isMobile
            end
        else
            if emoteGui then
                emoteGui:Destroy()
                emoteGui = nil
                emoteGuiButton = nil
            end
            if emoteInputConnection then
                emoteInputConnection:Disconnect()
                emoteInputConnection = nil
            end
        end
    end
})

player.CharacterAdded:Connect(function()
    if emoteGuiVisible and isMobile and not emoteGui then
        createEmoteGui(0)
    end
end)
   -- Player Tabs
   Tabs.Player:Section({ Title = "Player", TextSize = 40 })
    Tabs.Player:Divider()

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Debris = game:GetService("Debris")

local player = Players.LocalPlayer
local remoteEvent = ReplicatedStorage:WaitForChild("Events"):WaitForChild("Character"):WaitForChild("PassCharacterInfo")

local BOUNCE_HEIGHT = 0
local BOUNCE_EPSILON = 0.1
local BOUNCE_ENABLED = false
local touchConnections = {}

local function setupBounceOnTouch(character)
    if not BOUNCE_ENABLED then return end
    
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    
    if touchConnections[character] then
        touchConnections[character]:Disconnect()
        touchConnections[character] = nil
    end
    
    local touchConnection
    touchConnection = humanoidRootPart.Touched:Connect(function(hit)
        local playerBottom = humanoidRootPart.Position.Y - humanoidRootPart.Size.Y / 2
        local playerTop = humanoidRootPart.Position.Y + humanoidRootPart.Size.Y / 2
        local hitBottom = hit.Position.Y - hit.Size.Y / 2
        local hitTop = hit.Position.Y + hit.Size.Y / 2
        
        if hitTop <= playerBottom + BOUNCE_EPSILON then
            return
        elseif hitBottom >= playerTop - BOUNCE_EPSILON then
            return
        end
        
        remoteEvent:FireServer({}, {2})
        
        if BOUNCE_HEIGHT > 0 then
            local bodyVel = Instance.new("BodyVelocity")
            bodyVel.MaxForce = Vector3.new(0, math.huge, 0)
            bodyVel.Velocity = Vector3.new(0, BOUNCE_HEIGHT, 0)
            bodyVel.Parent = humanoidRootPart
            Debris:AddItem(bodyVel, 0.2)
        end
    end)
    
    touchConnections[character] = touchConnection
    
    character.AncestryChanged:Connect(function()
        if not character.Parent then
            if touchConnections[character] then
                touchConnections[character]:Disconnect()
                touchConnections[character] = nil
            end
        end
    end)
end

local function disableBounce()
    for character, connection in pairs(touchConnections) do
        if connection then
            connection:Disconnect()
            touchConnections[character] = nil
        end
    end
end

if player.Character then
    setupBounceOnTouch(player.Character)
end

player.CharacterAdded:Connect(setupBounceOnTouch)

if Tabs and Tabs.Player then
    Tabs.Player:Section({ Title = "Bounce Settings", TextSize = 20 })
    
    local BounceToggle
    local BounceHeightInput
    local EpsilonInput
    
    BounceToggle = Tabs.Player:Toggle({
        Title = "Enable Bounce",
        Value = false,
        Callback = function(state)
            BOUNCE_ENABLED = state
            if state then
                if player.Character then
                    setupBounceOnTouch(player.Character)
                end
            else
                disableBounce()
            end
            BounceHeightInput:Set({ Enabled = state })
            EpsilonInput:Set({ Enabled = state })
        end
    })

    BounceHeightInput = Tabs.Player:Input({
        Title = "Bounce Height",
        Placeholder = "0",
        Value = tostring(BOUNCE_HEIGHT),
        Numeric = true,
        Enabled = false,
        Callback = function(value)
            local num = tonumber(value)
            if num then
                BOUNCE_HEIGHT = math.max(0, num)
            end
        end
    })

    EpsilonInput = Tabs.Player:Input({
        Title = "Touch Detection Epsilon",
        Placeholder = "0.1",
        Value = tostring(BOUNCE_EPSILON),
        Numeric = true,
        Enabled = false,
        Callback = function(value)
            local num = tonumber(value)
            if num then
                BOUNCE_EPSILON = math.max(0, num)
            end
        end
    })
end
    InfiniteJumpToggle = Tabs.Player:Toggle({
        Title = "loc:INFINITE_JUMP",
        Value = false,
        Callback = function(state)
            featureStates.InfiniteJump = state
        end
    })

    JumpMethodDropdown = Tabs.Player:Dropdown({
        Title = "loc:JUMP_METHOD",
        Values = {"Hold", "Spam"},
        Value = "Hold",
        Callback = function(value)
            featureStates.JumpMethod = value
        end
    })

local infiniteSlideEnabled = false
local slideFrictionValue = -8
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")

local keys = {
    "Friction", "AirStrafeAcceleration", "JumpHeight", "RunDeaccel",
    "JumpSpeedMultiplier", "JumpCap", "SprintCap", "WalkSpeedMultiplier",
    "BhopEnabled", "Speed", "AirAcceleration", "RunAccel", "SprintAcceleration"
}

local function hasAll(tbl)
    if type(tbl) ~= "table" then return false end
    for _, k in ipairs(keys) do
        if rawget(tbl, k) == nil then return false end
    end
    return true
end

local cachedTables = nil
local plrModel = nil
local slideConnection = nil

local function getConfigTables()
    local tables = {}
    for _, obj in ipairs(getgc(true)) do
        local success, result = pcall(function()
            if hasAll(obj) then return obj end
        end)
        if success and result then
            table.insert(tables, obj)
        end
    end
    return tables
end

local function setFriction(value)
    if not cachedTables then return end
    for _, t in ipairs(cachedTables) do
        pcall(function()
            t.Friction = value
        end)
    end
end

local function updatePlayerModel()
    local GameFolder = workspace:FindFirstChild("Game")
    local PlayersFolder = GameFolder and GameFolder:FindFirstChild("Players")
    if PlayersFolder then
        plrModel = PlayersFolder:FindFirstChild(LocalPlayer.Name)
    else
        plrModel = nil
    end
end

local function onHeartbeat()
    if not plrModel then
        setFriction(5)
        return
    end
    local success, currentState = pcall(function()
        return plrModel:GetAttribute("State")
    end)
    if success and currentState then
        if currentState == "Slide" then
            pcall(function()
                plrModel:SetAttribute("State", "EmotingSlide")
            end)
        elseif currentState == "EmotingSlide" then
            setFriction(slideFrictionValue)
        else
            setFriction(5)
        end
    else
        setFriction(5)
    end
end

InfiniteSlideToggle = Tabs.Player:Toggle({
    Title = "Infinite Slide",
    Value = false,
    Callback = function(state)
        infiniteSlideEnabled = state
        
        if state then
            cachedTables = getConfigTables()
            updatePlayerModel()
            slideConnection = RunService.Heartbeat:Connect(onHeartbeat)
            
            LocalPlayer.CharacterAdded:Connect(function()
                task.wait(0.5)
                updatePlayerModel()
                if infiniteSlideEnabled then
                    cachedTables = getConfigTables()
                end
            end)
            
        else
            if slideConnection then
                slideConnection:Disconnect()
                slideConnection = nil
            end
            
            if cachedTables then
                for _, tableData in ipairs(cachedTables) do
                    pcall(function()
                        if tableData.obj and rawget(tableData.obj, "Friction") then
                            tableData.obj.Friction = 5
                        end
                    end)
                end
            end
            
            local currentTables = getConfigTables()
            for _, tableObj in ipairs(currentTables) do
                pcall(function()
                    if tableObj and rawget(tableObj, "Friction") then
                        tableObj.Friction = 5
                    end
                end)
            end
            
            if plrModel then
                pcall(function()
                    local currentState = plrModel:GetAttribute("State")
                    if currentState == "EmotingSlide" then
                        plrModel:SetAttribute("State", "Running")
                    end
                end)
            end
            
            cachedTables = nil
            plrModel = nil
        end
    end,
})

InfiniteSlideSpeedInput = Tabs.Player:Input({
    Title = "Set Infinite Slide Speed (Negative Only)",
    Value = tostring(slideFrictionValue),
    Placeholder = "-8 (negative only)",
    Callback = function(text)
        local num = tonumber(text)
        if num and num < 0 then
            slideFrictionValue = num
        end
    end,
})
    FlyToggle = Tabs.Player:Toggle({
        Title = "loc:FLY",
        Value = false,
        Callback = function(state)
            featureStates.Fly = state
            if state then
                startFlying()
            else
                stopFlying()
            end
        end
    })
local noclipConnections = {}
local noclipEnabled = false

local function setNoCollision()
    for _, object in pairs(workspace:GetDescendants()) do
        if object:IsA("BasePart") and not object:IsDescendantOf(player.Character) then
            object.CanCollide = false
        end
    end
end

local function restoreCollisions()
    for _, object in pairs(workspace:GetDescendants()) do
        if object:IsA("BasePart") and not object:IsDescendantOf(player.Character) then
            object.CanCollide = true
        end
    end
end

local function checkPlayerPosition()
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return end
    local humanoidRootPart = player.Character.HumanoidRootPart
    local rayOrigin = humanoidRootPart.Position
    local rayDistance = math.clamp(10, 1, 50)  
    local rayDirection = Vector3.new(0, -rayDistance, 0)
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {player.Character}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    local raycastResult = workspace:Raycast(rayOrigin, rayDirection, raycastParams)
    if raycastResult and raycastResult.Instance:IsA("BasePart") then
        raycastResult.Instance.CanCollide = true
    end
    for _, object in pairs(workspace:GetDescendants()) do
        if object:IsA("BasePart") and object ~= (raycastResult and raycastResult.Instance) and not object:IsDescendantOf(player.Character) then
            object.CanCollide = false
        end
    end
end

local function onCharacterAdded(newCharacter)
    character = newCharacter
    humanoidRootPart = newCharacter:WaitForChild("HumanoidRootPart")
    if noclipEnabled then
        setNoCollision()
    end
end

    local FlySpeedSlider = Tabs.Player:Slider({
        Title = "loc:FLY_SPEED",
        Value = { Min = 1, Max = 200, Default = 5, Step = 1 },
                Desc = "Adjust fly speed",
        Callback = function(value)
            featureStates.FlySpeed = value
        end
    })
NoclipToggle = Tabs.Player:Toggle({
    Title = "Noclip",
    Desc = "Note: This feature Can make you fall to the void non-stop so be careful what you're doing when toggles this on",
    Icon = "ghost",
    Callback = function(state)
        noclipEnabled = state
        if state then
            character = player.Character
            humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
            if character then
                setNoCollision()
            end
            noclipConnections.characterAdded = player.CharacterAdded:Connect(onCharacterAdded)
            noclipConnections.descendantAdded = workspace.DescendantAdded:Connect(function(descendant)
                if noclipEnabled and descendant:IsA("BasePart") and not descendant:IsDescendantOf(player.Character) then
                    descendant.CanCollide = false
                end
            end)
            noclipConnections.heartbeat = RunService.Heartbeat:Connect(checkPlayerPosition)
        else
            for _, conn in pairs(noclipConnections) do
                if conn then conn:Disconnect() end
            end
            noclipConnections = {}
            restoreCollisions()
        end
    end
})
    TPWALKToggle = Tabs.Player:Toggle({
        Title = "loc:TPWALK",
        Value = false,
        Callback = function(state)
            featureStates.TPWALK = state
            if state then
                startTpwalk()
            else
                stopTpwalk()
            end
        end
    })

    local TPWALKSlider = Tabs.Player:Slider({
        Title = "loc:TPWALK_VALUE",
         Desc = "Adjust TPWALK speed",
        Value = { Min = 1, Max = 200, Default = 1, Step = 1 },
        Callback = function(value)
            featureStates.TpwalkValue = value
        end
    })

    JumpBoostToggle = Tabs.Player:Toggle({
        Title = "loc:JUMP_HEIGHT",
        Value = false,
        Callback = function(state)
            featureStates.JumpBoost = state
            if state then
                startJumpBoost()
            else
                stopJumpBoost()
            end
        end
    })

    local JumpBoostSlider = Tabs.Player:Slider({
        Title = "loc:JUMP_POWER",
        Desc = "Adjust jump height",
        Value = { Min = 1, Max = 200, Default = 5, Step = 1 },
        Callback = function(value)
            featureStates.JumpPower = value
            if featureStates.JumpBoost then
                if humanoid then
                    humanoid.JumpPower = featureStates.JumpPower
                end
            end
        end
    })

Tabs.Player:Section({ Title = "Modifications" })

local function createValidatedInput(config)
    return function(input)
        local val = tonumber(input)
        if not val then return end
        
        if config.min and val < config.min then return end
        if config.max and val > config.max then return end
        
        currentSettings[config.field] = tostring(val)
        applyToTables(function(obj)
            obj[config.field] = val
        end)
    end
end

SpeedInput = Tabs.Player:Input({
    Title = "Set Speed",
    Icon = "speedometer",
    Placeholder = "Default 1500",
    Value = currentSettings.Speed,
    Callback = createValidatedInput({
        field = "Speed",
        min = 1450,
        max = 100008888
    })
})

JumpCapInput = Tabs.Player:Input({
    Title = "Set Jump Cap",
    Icon = "chevrons-up",
    Placeholder = "Default 1",
    Value = currentSettings.JumpCap,
    Callback = createValidatedInput({
        field = "JumpCap",
        min = 0.1,
        max = 5088888
    })
})

StrafeInput = Tabs.Player:Input({
    Title = "Strafe Acceleration",
    Icon = "wind",
    Placeholder = "Default 187",
    Value = currentSettings.AirStrafeAcceleration,
    Callback = createValidatedInput({
        field = "AirStrafeAcceleration",
        min = 1,
        max = 1000888888
    })
})

ApplyMethodDropdown = Tabs.Player:Dropdown({
    Title = "Select Apply Method",
    Values = { "Not Optimized", "Optimized" },
    Multi = false,
    Default = getgenv().ApplyMode,
    Callback = function(value)
        getgenv().ApplyMode = value
    end
})
Tabs.Player:Section({ Title = "Emote Speed (BETA)" })
originalEmoteSpeeds = {}
itemsFolder = game:GetService("ReplicatedStorage"):FindFirstChild("Items")
if itemsFolder then
    emotesFolder = itemsFolder:FindFirstChild("Emotes")
    if emotesFolder then
        for _, emoteModule in ipairs(emotesFolder:GetChildren()) do
            if emoteModule:IsA("ModuleScript") then
                success, emoteData = pcall(require, emoteModule)
                if success and emoteData and emoteData.EmoteInfo then
                    originalEmoteSpeeds[emoteModule.Name] = emoteData.EmoteInfo.SpeedMult
                end
            end
        end
    end
end

function applyEmoteSpeed(speedValue)
    if not itemsFolder then return end
    emotesFolder = itemsFolder:FindFirstChild("Emotes")
    if not emotesFolder then return end
    
    for _, emoteModule in ipairs(emotesFolder:GetChildren()) do
        if emoteModule:IsA("ModuleScript") then
            success, emoteData = pcall(require, emoteModule)
            if success and emoteData and emoteData.EmoteInfo and emoteData.EmoteInfo.SpeedMult ~= 0 then
                emoteData.EmoteInfo.SpeedMult = speedValue
            end
        end
    end
end

function restoreOriginalEmoteSpeeds()
    if not itemsFolder then return end
    emotesFolder = itemsFolder:FindFirstChild("Emotes")
    if not emotesFolder then return end
    
    for _, emoteModule in ipairs(emotesFolder:GetChildren()) do
        if emoteModule:IsA("ModuleScript") then
            originalSpeed = originalEmoteSpeeds[emoteModule.Name]
            if originalSpeed then
                success, emoteData = pcall(require, emoteModule)
                if success and emoteData and emoteData.EmoteInfo then
                    emoteData.EmoteInfo.SpeedMult = originalSpeed
                end
            end
        end
    end
end

function getMatchingTables()
    matched = {}
    for _, obj in pairs(getgc(true)) do
        if typeof(obj) == "table" then
            ok = true
            for field in pairs(requiredFields) do
                if rawget(obj, field) == nil then
                    ok = false
                    break
                end
            end
            if ok then
                table.insert(matched, obj)
            end
        end
    end
    return matched
end

function applySpeedMultiplier(speedMultiplier)
    targets = getMatchingTables()
    for _, tableObj in ipairs(targets) do
        if tableObj and typeof(tableObj) == "table" then
            pcall(function()
                tableObj.WalkSpeedMultiplier = speedMultiplier
            end)
        end
    end
end

function getPlayerObj()
    gamePlayers = workspace.Game and workspace.Game.Players
    if not gamePlayers then return nil end
    return gamePlayers:FindFirstChild(player.Name)
end

playerObj = nil
connection = nil

function setupConnection(obj)
    if connection then 
        connection:Disconnect() 
        connection = nil
    end
    playerObj = obj
    if not obj then return end
    
    function onStateChanged()
        state = obj:GetAttribute("State")
        targetSpeed = (state == "Emoting") and emotingSpeed or 1.5
        applySpeedMultiplier(targetSpeed)
    end
    
    onStateChanged()
    connection = obj:GetAttributeChangedSignal("State"):Connect(onStateChanged)
end

emotingSpeed = 1.5

function resetMultiplierSpeed()
    emotingSpeed = 1.5
    applySpeedMultiplier(1.5)
end

EmoteSpeedModeDropdown = Tabs.Player:Dropdown({
    Title = "Emote speed mode",
    Values = {"Nah", "Legit", "Multiplier speed"},
    Value = "Nah",
    Callback = function(value)
        if value == "Nah" then
            resetMultiplierSpeed()
            restoreOriginalEmoteSpeeds()
            if connection then 
                connection:Disconnect() 
                connection = nil
            end
        elseif value == "Multiplier speed" then
            restoreOriginalEmoteSpeeds()
            setupConnection(getPlayerObj())
            task.spawn(function()
                while EmoteSpeedModeDropdown.Value == "Multiplier speed" do
                    task.wait(2)
                    current = getPlayerObj()
                    if current ~= playerObj then
                        setupConnection(current)
                    elseif playerObj then
                        state = playerObj:GetAttribute("State")
                        targetSpeed = (state == "Emoting") and emotingSpeed or 1.5
                        applySpeedMultiplier(targetSpeed)
                    end
                end
            end)
        elseif value == "Legit" then
            resetMultiplierSpeed()
            if connection then 
                connection:Disconnect() 
                connection = nil
            end
            speedValue = featureStates.EmoteSpeedValue or 2
            applyEmoteSpeed(speedValue)
        end
    end
})
EmoteSpeedInput = Tabs.Player:Input({
    Title = "Emote Speed Value",
    Placeholder = "1500",
    NumbersOnly = true,
    Callback = function(value)
        num = tonumber(value)
        if num and num > 0 then
            featureStates.EmoteSpeedValue = num
            if EmoteSpeedModeDropdown.Value == "Legit" then
                appliedValue = num / 1000
                applyEmoteSpeed(appliedValue)
            elseif EmoteSpeedModeDropdown.Value == "Multiplier speed" then
                appliedValue = num / 1000
                emotingSpeed = appliedValue
            end
        end
    end
})
ApplyUnwalkableButton = Tabs.Player:Button({
    Title = "Apply Speed unwalkable Emote",
    Callback = function()
        if not itemsFolder then return end
        
        emotesFolder = itemsFolder:FindFirstChild("Emotes")
        if not emotesFolder then return end
        
        speedValue = featureStates.EmoteSpeedValue or 2
        
        for _, emoteModule in ipairs(emotesFolder:GetChildren()) do
            if emoteModule:IsA("ModuleScript") then
                success, emoteData = pcall(require, emoteModule)
                if success and emoteData and emoteData.EmoteInfo and emoteData.EmoteInfo.SpeedMult == 0 then
                    emoteData.EmoteInfo.SpeedMult = speedValue
                end
            end
        end
    end
})

ResetEmoteSpeedButton = Tabs.Player:Button({
    Title = "Reset Emote Speed",
    Desc= "Having Trouble? reset the speed or rejoin",
    Callback = function()
        restoreOriginalEmoteSpeeds()
        resetMultiplierSpeed()
    end
})
    -- Visuals Tab
    Tabs.Visuals:Section({ Title = "Visual", TextSize = 20 })
    Tabs.Visuals:Divider()
    local cameraStretchConnection
local function setupCameraStretch()
    cameraStretchConnection = nil
    local stretchHorizontal = 0.80
    local stretchVertical = 0.80
    CameraStretchToggle = Tabs.Visuals:Toggle({
        Title = "Camera Stretch",
        Value = false,
        Callback = function(state)
            if state then
                if cameraStretchConnection then cameraStretchConnection:Disconnect() end
                cameraStretchConnection = game:GetService("RunService").RenderStepped:Connect(function()
                    local Camera = workspace.CurrentCamera
                    Camera.CFrame = Camera.CFrame * CFrame.new(0, 0, 0, stretchHorizontal, 0, 0, 0, stretchVertical, 0, 0, 0, 1)
                end)
            else
                if cameraStretchConnection then
                    cameraStretchConnection:Disconnect()
                    cameraStretchConnection = nil
                end
            end
        end
    })

    CameraStretchHorizontalInput = Tabs.Visuals:Input({
        Title = "Camera Stretch Horizontal",
        Placeholder = "0.80",
        Numeric = true,
        Value = tostring(stretchHorizontal),
        Callback = function(value)
            local num = tonumber(value)
            if num then
                stretchHorizontal = num
                if cameraStretchConnection then
                    cameraStretchConnection:Disconnect()
                    cameraStretchConnection = game:GetService("RunService").RenderStepped:Connect(function()
                        local Camera = workspace.CurrentCamera
                        Camera.CFrame = Camera.CFrame * CFrame.new(0, 0, 0, stretchHorizontal, 0, 0, 0, stretchVertical, 0, 0, 0, 1)
                    end)
                end
            end
        end
    })

    CameraStretchVerticalInput = Tabs.Visuals:Input({
        Title = "Camera Stretch Vertical",
        Placeholder = "0.80",
        Numeric = true,
        Value = tostring(stretchVertical),
        Callback = function(value)
            local num = tonumber(value)
            if num then
                stretchVertical = num
                if cameraStretchConnection then
                    cameraStretchConnection:Disconnect()
                    cameraStretchConnection = game:GetService("RunService").RenderStepped:Connect(function()
                        local Camera = workspace.CurrentCamera
                        Camera.CFrame = Camera.CFrame * CFrame.new(0, 0, 0, stretchHorizontal, 0, 0, 0, stretchVertical, 0, 0, 0, 1)
                    end)
                end
            end
        end
    })
end

setupCameraStretch()


local module_upvr = {}
module_upvr.__index = module_upvr

local currentModuleInstance = nil

function module_upvr.new()
    if currentModuleInstance then
        currentModuleInstance = nil
    end

    local player = game.Players.LocalPlayer
    local playerGui = player:WaitForChild("PlayerGui", 5)
    local self = setmetatable({
        Player = player,
        Enabled = false,
        Visible = false,
    }, module_upvr)

    local nextbotNoise
    local success, err = pcall(function()
        local shared = playerGui:FindFirstChild("Shared")
        if shared then
            local hud = shared:FindFirstChild("HUD")
            if hud then
                nextbotNoise = hud:FindFirstChild("NextbotNoise")
            end
        end
        if not nextbotNoise then
            local hud = playerGui:FindFirstChild("HUD")
            if hud then
                nextbotNoise = hud:FindFirstChild("NextbotNoise")
            end
        end
        if not nextbotNoise then
            nextbotNoise = playerGui:FindFirstChild("NextbotNoise")
        end
    end)

    if not success or not nextbotNoise then
        warn("Failed to find NextbotNoise in PlayerGui: " .. (err or "Unknown error"))
        return self
    end

    self.originalSize = nextbotNoise.Size
    self.originalPosition = nextbotNoise.Position
    self.originalImageTransparency = nextbotNoise.ImageTransparency
    self.originalNoiseTransparency = nextbotNoise:FindFirstChild("Noise") and nextbotNoise.Noise.ImageTransparency or 0
    self.originalNoise2Transparency = nextbotNoise:FindFirstChild("Noise2") and nextbotNoise.Noise2.ImageTransparency or 0

    local transparencySuccess, transparencyErr = pcall(function()
        local inset = game:GetService("GuiService"):GetGuiInset()
        nextbotNoise.Position = UDim2.new(0.5, 0, 0, -inset.Y)
        nextbotNoise.Size = UDim2.new(0, 0, 0, 0)
        nextbotNoise.ImageTransparency = 1
        if nextbotNoise:FindFirstChild("Noise") then
            nextbotNoise.Noise.ImageTransparency = 1
        else
            warn("Noise not found in NextbotNoise")
        end
        if nextbotNoise:FindFirstChild("Noise2") then
            nextbotNoise.Noise2.ImageTransparency = 1
        else
            warn("Noise2 not found in NextbotNoise")
        end
    end)

    if not transparencySuccess then
        warn("Failed to set vignette properties: " .. transparencyErr)
    end

    self.Noise = nextbotNoise
    currentModuleInstance = self
    return self
end

function module_upvr.stop(self)
    if self.Noise then
        local success, err = pcall(function()
            self.Noise.Size = self.originalSize
            self.Noise.Position = self.originalPosition
            self.Noise.ImageTransparency = self.originalImageTransparency
            if self.Noise:FindFirstChild("Noise") then
                self.Noise.Noise.ImageTransparency = self.originalNoiseTransparency
            end
            if self.Noise:FindFirstChild("Noise2") then
                self.Noise.Noise2.ImageTransparency = self.originalNoise2Transparency
            end
        end)
        if not success then
            warn("Failed to restore vignette properties: " .. err)
        end
    end
    currentModuleInstance = nil
end

function module_upvr.Update(arg1, arg2)
    if arg1 and arg1.Noise then
        local success, err = pcall(function()
            if arg1.Noise:IsA("ImageLabel") or arg1.Noise:IsA("Frame") then
                arg1.Noise.ImageTransparency = 1
                if arg1.Noise:FindFirstChild("Noise") then
                    arg1.Noise.Noise.ImageTransparency = 1
                end
                if arg1.Noise:FindFirstChild("Noise2") then
                    arg1.Noise.Noise2.ImageTransparency = 1
                end
            end
        end)
        if not success then
            warn("Update failed to set transparencies: " .. err)
        end
    end
end



local stableCameraInstance = nil

local StableCamera = {}
StableCamera.__index = StableCamera

function StableCamera.new(maxDistance)
    local self = setmetatable({}, StableCamera)
    self.Player = Players.LocalPlayer
    self.MaxDistance = maxDistance or 50
    self._conn = RunService.RenderStepped:Connect(function(dt) self:Update(dt) end)
    return self
end

local function tryResetShake(player)
    if not player then return end
    local ok, playerScripts = pcall(function() return player:FindFirstChild("PlayerScripts") end)
    if not ok or not playerScripts then return end
    local cameraSet = playerScripts:FindFirstChild("Camera") and playerScripts.Camera:FindFirstChild("Set")
    if cameraSet and type(cameraSet.Invoke) == "function" then
        pcall(function()
            cameraSet:Invoke("CFrameOffset", "Shake", CFrame.new())
        end)
    end
end

function StableCamera:Update(dt)
    if Players and Players.LocalPlayer then
        tryResetShake(Players.LocalPlayer)
    end
end

function StableCamera:Destroy()
    if self._conn then
        self._conn:Disconnect()
        self._conn = nil
    end
end

DisableCameraShakeToggle = Tabs.Visuals:Toggle({
    Title = "Disable Camera Shake",
    Value = false,
    Callback = function(state)
        featureStates.DisableCameraShake = state
        if state then
            if stableCameraInstance then
                stableCameraInstance:Destroy()
                stableCameraInstance = nil
            end
            stableCameraInstance = StableCamera.new(50)
            pcall(function()
                WindUI:Notify({ Title = "Camera", Content = "Camera shake disabled", Duration = 0 })
            end)
        else
            if stableCameraInstance then
                stableCameraInstance:Destroy()
                stableCameraInstance = nil
            end
            pcall(function()
                WindUI:Notify({ Title = "Camera", Content = "Camera shake enabled", Duration = 0 })
            end)
        end
    end
})

local vignetteEnabled = false

Disablevignette = Tabs.Visuals:Toggle({
    Title = "Disable Vignette",
    Default = false,
    Callback = function(value)
        vignetteEnabled = value
        if value then
            local vignetteInstance = module_upvr.new()
            if vignetteInstance then
                vignetteConnection = game:GetService("RunService").Heartbeat:Connect(function(dt)
                    module_upvr.Update(vignetteInstance, dt)
                end)
            end
        else
            if vignetteConnection then
                vignetteConnection:Disconnect()
                vignetteConnection = nil
            end
            if currentModuleInstance then
                module_upvr.stop(currentModuleInstance)
            end
        end
    end
})

game.Players.LocalPlayer.CharacterAdded:Connect(function()
    warn("Player respawned - checking vignette disable")
    wait(1)
    
    if vignetteEnabled then
        warn("Reapplying vignette disable after respawn")
        local vignetteInstance = module_upvr.new()
        if vignetteInstance then
            if vignetteConnection then
                vignetteConnection:Disconnect()
            end
            vignetteConnection = game:GetService("RunService").Heartbeat:Connect(function(dt)
                module_upvr.Update(vignetteInstance, dt)
            end)
        end
    end
end)

	    FullBrightToggle = Tabs.Visuals:Toggle({
    Title = "Full Bright",
    Desc = "Ya Like drinking Night Vision while mining in da cave and sceard of creeper blow you up dawg?",
    Value = false,
    Callback = function(state)
        featureStates.FullBright = state
        if state then
            Lighting = game:GetService("Lighting")
            
            featureStates.originalBrightness = Lighting.Brightness
            featureStates.originalAmbient = Lighting.Ambient
            featureStates.originalOutdoorAmbient = Lighting.OutdoorAmbient
            featureStates.originalColorShiftBottom = Lighting.ColorShift_Bottom
            featureStates.originalColorShiftTop = Lighting.ColorShift_Top
            
            Lighting.Brightness = 2
            Lighting.Ambient = Color3.new(1, 1, 1)
            Lighting.OutdoorAmbient = Color3.new(1, 1, 1)
            Lighting.ColorShift_Bottom = Color3.new(1, 1, 1)
            Lighting.ColorShift_Top = Color3.new(1, 1, 1)
            
            for _, obj in pairs(Lighting:GetDescendants()) do
                if obj:IsA("BloomEffect") or obj:IsA("BlurEffect") or obj:IsA("ColorCorrectionEffect") or obj:IsA("SunRaysEffect") then
                    obj.Enabled = false
                end
            end
            
            featureStates.fullBrightConnection = game.Players.LocalPlayer.CharacterAdded:Connect(function()
                Lighting.Brightness = 2
                Lighting.Ambient = Color3.new(1, 1, 1)
                Lighting.OutdoorAmbient = Color3.new(1, 1, 1)
                Lighting.ColorShift_Bottom = Color3.new(1, 1, 1)
                Lighting.ColorShift_Top = Color3.new(1, 1, 1)
            end)
        else
            if featureStates.fullBrightConnection then
                featureStates.fullBrightConnection:Disconnect()
                featureStates.fullBrightConnection = nil
            end
            
            if featureStates.originalBrightness then
                Lighting = game:GetService("Lighting")
                Lighting.Brightness = featureStates.originalBrightness
                Lighting.Ambient = featureStates.originalAmbient
                Lighting.OutdoorAmbient = featureStates.originalOutdoorAmbient
                Lighting.ColorShift_Bottom = featureStates.originalColorShiftBottom
                Lighting.ColorShift_Top = featureStates.originalColorShiftTop
            end
            
            for _, obj in pairs(Lighting:GetDescendants()) do
                if obj:IsA("BloomEffect") or obj:IsA("BlurEffect") or obj:IsA("ColorCorrectionEffect") or obj:IsA("SunRaysEffect") then
                    obj.Enabled = true
                end
            end
        end
    end
})

NoFogToggle = Tabs.Visuals:Toggle({
    Title = "loc:NO_FOG",
    Value = false,
    Callback = function(state)
        featureStates.NoFog = state
        if state then
            startNoFog()
        else
            stopNoFog()
        end
    end
})
local originalFOV = workspace.CurrentCamera.FieldOfView
local FOVSlider = Tabs.Visuals:Slider({
    Title = "Field of View",
    Desc = "Old fov has been moved to settings, will be add back in here soon",
    Value = { Min = 10, Max = 120, Default = originalFOV, Step = 1 },
    Callback = function(value)
        workspace.CurrentCamera.FieldOfView = tonumber(value)
    end
})
TimerDisplayToggle = Tabs.Visuals:Toggle({
    Title = "Timer Display",
    Value = false,
    Callback = function(state)
        featureStates.TimerDisplay = state

        local function getRoundTimer()
            local player = game:GetService("Players").LocalPlayer
            local pg = player.PlayerGui
            local shared = pg:FindFirstChild("Shared")
            local hud = shared and shared:FindFirstChild("HUD")
            local overlay = hud and hud:FindFirstChild("Overlay")
            local default = overlay and overlay:FindFirstChild("Default")
            local ro = default and default:FindFirstChild("RoundOverlay")
            local round = ro and ro:FindFirstChild("Round")
            return round and round:FindFirstChild("RoundTimer")
        end

        local function setContainerVisible(visible)
            local pg = game:GetService("Players").LocalPlayer.PlayerGui
            local main = pg:FindFirstChild("MainInterface")
            if main then
                local container = main:FindFirstChild("TimerContainer")
                if container then
                    container.Visible = visible
                end
            end
        end

        if state then
            task.spawn(function()
                while featureStates.TimerDisplay do
                    local timer = getRoundTimer()
                    if timer then
                        setContainerVisible(not timer.Visible)
                    else
                        setContainerVisible(true)
                    end
                    task.wait(0.1)
                end
                setContainerVisible(false)
            end)
        else
            setContainerVisible(false)
        end
    end
})
    Tabs.Visuals:Section({ Title = "Cosmetics Changer", TextSize = 20 })
    Tabs.Visuals:Divider()
    
    local cosmetic1, cosmetic2 = "" --made by @.scv8 discord server https://discord.gg/RBZVmT6UKs
    
    Tabs.Visuals:Input({
        Title = "Current Cosmetics",
        Placeholder = "",
        Callback = function(v) cosmetic1 = v end
    })
    
    Tabs.Visuals:Input({
        Title = "Select Cosmetics",
        Placeholder = "",
        Callback = function(v) cosmetic2 = v end
    })
    
    Tabs.Visuals:Button({
        Title = "Apply Cosmetics",
        Callback = function()
            pcall(function()
                if cosmetic1 == "" or cosmetic2 == "" or cosmetic1 == cosmetic2 then return end
                
                local ReplicatedStorage = game:GetService("ReplicatedStorage")    
                local Cosmetics = ReplicatedStorage:WaitForChild("Items"):WaitForChild("Cosmetics")    
                
                local function normalize(str)    
                    return str:gsub("%s+", ""):lower()    
                end    
                
                local function levenshtein(s, t)    
                    local m, n = #s, #t    
                    local d = {}    
                    for i = 0, m do d[i] = {[0] = i} end    
                    for j = 0, n do d[0][j] = j end    
                    
                    for i = 1, m do    
                        for j = 1, n do    
                            local cost = (s:sub(i,i) == t:sub(j,j)) and 0 or 1    
                            d[i][j] = math.min(    
                                d[i-1][j] + 1,    
                                d[i][j-1] + 1,    
                                d[i-1][j-1] + cost    
                            )    
                        end    
                    end    
                    return d[m][n]    
                end    
                
                local function similarity(s, t)    
                    local nS, nT = normalize(s), normalize(t)    
                    local dist = levenshtein(nS, nT)    
                    return 1 - dist / math.max(#nS, #nT)    
                end    
                
                local function findSimilar(name)    
                    local bestMatch = name    
                    local bestScore = 0.5    
                    for _, c in ipairs(Cosmetics:GetChildren()) do    
                        local score = similarity(name, c.Name)    
                        if score > bestScore then    
                            bestScore = score    
                            bestMatch = c.Name    
                        end    
                    end    
                    return bestMatch    
                end    
                
                cosmetic1 = findSimilar(cosmetic1)    
                cosmetic2 = findSimilar(cosmetic2)    
                
                local a = Cosmetics:FindFirstChild(cosmetic1)    
                local b = Cosmetics:FindFirstChild(cosmetic2)    
                if not a or not b then return end    
                
                local tempRoot = Instance.new("Folder", Cosmetics)    
                tempRoot.Name = "__temp_swap_" .. tostring(tick()):gsub("%.", "_")    
                
                local tempA = Instance.new("Folder", tempRoot)    
                local tempB = Instance.new("Folder", tempRoot)    
                
                for _, c in ipairs(a:GetChildren()) do c.Parent = tempA end    
                for _, c in ipairs(b:GetChildren()) do c.Parent = tempB end    
                
                for _, c in ipairs(tempA:GetChildren()) do c.Parent = b end    
                for _, c in ipairs(tempB:GetChildren()) do c.Parent = a end    
                
                tempRoot:Destroy()    
            end)    
        end
    })
    Tabs.Visuals:Section({ Title = "Emote Changer", TextSize = 20 })
    Tabs.Visuals:Divider()
    
    for i=1,12 do
        Tabs.Visuals:Input({
            Title="Current Emote "..i,
            Placeholder="Enter current emote name",
            Value=currentEmotes[i],
            Callback=function(v) 
                currentEmotes[i]=v:gsub("%s+", "")
            end
        })
    end
    
    Tabs.Visuals:Divider()
    
    for i=1,12 do
        Tabs.Visuals:Input({
            Title="Select Emote "..i,
            Placeholder="Enter select emote name",
            Value=selectEmotes[i],
            Callback=function(v) 
                selectEmotes[i]=v:gsub("%s+", "")
            end
        })
    end
    
    Tabs.Visuals:Button({
        Title="Apply Emote Mappings",
        Icon="refresh-cw",
        Callback=function()
            for i=1,12 do
                emoteEnabled[i] = (currentEmotes[i]~="" and selectEmotes[i]~="")
            end
            WindUI:Notify({Title="Emote Changer",Content="Emote mappings applied!"})
        end
    })

    Tabs.Visuals:Button({
        Title="Reset All Emotes",
        Icon="trash-2",
        Callback=function()
            for i=1,12 do
                currentEmotes[i]=""
                selectEmotes[i]=""
                emoteEnabled[i]=false
            end
            WindUI:Notify({Title="Emote Changer",Content="All emotes reset!"})
        end
     })
     Tabs.Visuals:Section({ Title = "Character", TextSize = 20 })
VisualNametagDropdown = Tabs.Visuals:Dropdown({
    Title = "Visual Nametag",
    Desc = "Select nametag appearance",
    Values = {"Ignore", "None"},
    Value = "Ignore",
    Callback = function(value)
        playerFolder = workspace.Game.Players:FindFirstChild(game.Players.LocalPlayer.Name)
        if playerFolder then
            if value == "None" then
                playerFolder:SetAttribute("Nametag", nil)
            elseif value ~= "Ignore" then
                cleanValue = value:gsub("%s+", "")
                playerFolder:SetAttribute("Nametag", cleanValue)
            end
        end
    end
})

function updateNametagList()
    nametagValues = {"Ignore", "None"}
    nametagsFolder = game:GetService("ReplicatedStorage").Items.Nametags
    
    if nametagsFolder then
        for _, nametagModule in ipairs(nametagsFolder:GetChildren()) do
            if nametagModule:IsA("ModuleScript") then
                success, nametagData = pcall(require, nametagModule)
                if success and nametagData and nametagData.AppearanceInfo then
                    table.insert(nametagValues, nametagData.AppearanceInfo.Name)
                end
            end
        end
    end
    
    VisualNametagDropdown:Refresh(nametagValues, "Ignore")
end

updateNametagList()

game.Players.LocalPlayer.CharacterAdded:Connect(function(character)
    wait(1)
    playerFolder = workspace.Game.Players:FindFirstChild(game.Players.LocalPlayer.Name)
    if playerFolder and VisualNametagDropdown.Value ~= "Ignore" then
        if VisualNametagDropdown.Value == "None" then
            playerFolder:SetAttribute("Nametag", nil)
        else
            cleanValue = VisualNametagDropdown.Value:gsub("%s+", "")
            playerFolder:SetAttribute("Nametag", cleanValue)
        end
    end
end)

game:GetService("RunService").Heartbeat:Connect(function()
    playerFolder = workspace.Game.Players:FindFirstChild(game.Players.LocalPlayer.Name)
    if playerFolder and VisualNametagDropdown.Value ~= "Ignore" then
        if VisualNametagDropdown.Value == "None" then
            playerFolder:SetAttribute("Nametag", nil)
        else
            cleanValue = VisualNametagDropdown.Value:gsub("%s+", "")
            currentTag = playerFolder:GetAttribute("Nametag")
            if currentTag ~= cleanValue then
                playerFolder:SetAttribute("Nametag", cleanValue)
            end
        end
    end
end)
     -- ESP Tab
playerEspElements = {}
playerEspConnection = nil
nextbotEspElements = {}
nextbotEspConnection = nil
downedTracerConnection = nil
downedNameESPConnection = nil
downedTracerLines = {}
downedNameESPLabels = {}

nextBotNames = {}
if ReplicatedStorage:FindFirstChild("NPCs") then
    for _, npc in ipairs(ReplicatedStorage.NPCs:GetChildren()) do
        table.insert(nextBotNames, npc.Name)
    end
end

function isNextbotModel(model)
    if not model or not model.Name then return false end
    for _, name in ipairs(nextBotNames) do
        if model.Name == name then return true end
    end
    return false
end

function getDistanceFromPlayer(targetPosition)
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return 0 end
    return (targetPosition - player.Character.HumanoidRootPart.Position).Magnitude
end

function cleanupTracers(tracerTable)
    for _, drawing in ipairs(tracerTable) do
        if drawing and drawing.Remove then 
            pcall(function() drawing:Remove() end)
        elseif drawing then 
            drawing.Visible = false 
        end
    end
    tracerTable = {}
end

function cleanupNameESPLabels(labelTable)
    for _, label in ipairs(labelTable) do
        if label and label.Remove then 
            label:Remove()
        elseif label then 
            label.Visible = false 
        end
    end
    labelTable = {}
end

function createESPObject()
    return {
        box = Drawing.new("Square"),
        tracer = Drawing.new("Line"),
        name = Drawing.new("Text"),
        distance = Drawing.new("Text"),
        boxLines = {}
    }
end

function setupESPObject(esp)
    esp.box.Thickness = 2
    esp.box.Filled = false
    esp.tracer.Thickness = 1
    esp.name.Size = 14
    esp.name.Center = true
    esp.name.Outline = true
    esp.distance.Size = 14
    esp.distance.Center = true
    esp.distance.Outline = true
end

function cleanupDrawingTable(drawingTable)
    for _, drawing in pairs(drawingTable) do
        if type(drawing) == "table" then
            for _, line in ipairs(drawing) do
                pcall(line.Remove, line)
            end
        else
            pcall(drawing.Remove, drawing)
        end
    end
end

function draw3DBox(esp, hrp, camera, boxColor, boxSize)
    if not hrp or not camera then return end
    
    boxSize = boxSize or Vector3.new(4, 5, 3)
    local size = boxSize
    local offsets = {
        Vector3.new( size.X/2,  size.Y/2,  size.Z/2), Vector3.new( size.X/2,  size.Y/2, -size.Z/2),
        Vector3.new( size.X/2, -size.Y/2,  size.Z/2), Vector3.new( size.X/2, -size.Y/2, -size.Z/2),
        Vector3.new(-size.X/2,  size.Y/2,  size.Z/2), Vector3.new(-size.X/2,  size.Y/2, -size.Z/2),
        Vector3.new(-size.X/2, -size.Y/2,  size.Z/2), Vector3.new(-size.X/2, -size.Y/2, -size.Z/2),
    }
    
    local screenPoints = {}
    local anyPointOnScreen = false

    for i, offset in ipairs(offsets) do
        local success, vec, onScreen = pcall(function()
            local worldPos = hrp.CFrame * CFrame.Angles(0, math.rad(90), 0) * offset
            return camera:WorldToViewportPoint(worldPos)
        end)
        if success then
            screenPoints[i] = {pos = Vector2.new(vec.X, vec.Y), depth = vec.Z, onScreen = onScreen}
            if onScreen and vec.Z > 0 then anyPointOnScreen = true end
        end
    end

    if not esp.boxLines or #esp.boxLines == 0 then
        esp.boxLines = {}
        for i = 1, 12 do
            local line = Drawing.new("Line")
            line.Thickness = 1
            line.ZIndex = 2
            table.insert(esp.boxLines, line)
        end
    end

    local edges = {
        {1, 2}, {1, 3}, {1, 5}, {2, 4}, {2, 6},
        {3, 4}, {3, 7}, {5, 6}, {5, 7}, {4, 8}, {6, 8}, {7, 8}
    }

    local distance = (player.Character and player.Character:FindFirstChild("HumanoidRootPart") and 
        (player.Character.HumanoidRootPart.Position - hrp.Position).Magnitude) or 10
    local thickness = math.clamp(3 / (distance / 50), 1, 3)

    for i, edge in ipairs(edges) do
        local line = esp.boxLines[i]
        if line then
            local p1, p2 = screenPoints[edge[1]], screenPoints[edge[2]]
            line.Color = boxColor or Color3.fromRGB(255, 255, 255)
            line.Thickness = thickness
            line.Transparency = 1
            if anyPointOnScreen and p1 and p2 and p1.depth > 0 and p2.depth > 0 then
                line.From = p1.pos
                line.To = p2.pos
                line.Visible = true
            else
                line.Visible = false
            end
        end
    end
end

function updatePlayerESP()
    local camera = workspace.CurrentCamera
    if not camera then return end
    
    local screenBottomCenter = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y)
    local currentTargets = {}
    local gameFolder = workspace:FindFirstChild("Game")

    if gameFolder and gameFolder:FindFirstChild("Players") then
        for _, model in pairs(gameFolder.Players:GetChildren()) do
            if model:IsA("Model") and model:FindFirstChild("HumanoidRootPart") then
                local isPlayer = Players:GetPlayerFromCharacter(model) ~= nil
                local humanoid = model:FindFirstChild("Humanoid")
                
                if isPlayer and model.Name ~= player.Name and humanoid and humanoid.Health > 0 then
                    currentTargets[model] = true
                    
                    if not playerEspElements[model] then
                        playerEspElements[model] = createESPObject()
                        setupESPObject(playerEspElements[model])
                    end

                    local esp = playerEspElements[model]
                    local hrp = model.HumanoidRootPart
                    local vector, onScreen = camera:WorldToViewportPoint(hrp.Position)

                    if onScreen then
                        local topY = camera:WorldToViewportPoint(hrp.Position + Vector3.new(0, 3, 0)).Y
                        local bottomY = camera:WorldToViewportPoint(hrp.Position - Vector3.new(0, 3, 0)).Y
                        local size = (bottomY - topY) / 2
                        local toggles = featureStates.PlayerESP
                        local boxSize = humanoid and Vector3.new(2, humanoid.HipHeight + 5, 2) or Vector3.new(4, 5, 3)

                        if toggles.boxes then
                            local boxColor = toggles.rainbowBoxes and Color3.fromHSV((tick() % 5) / 5, 1, 1) or Color3.fromRGB(0, 255, 0)
                            if toggles.boxType == "2D" then
                                esp.box.Visible = true
                                esp.box.Size = Vector2.new(size * 2, size * 3)
                                esp.box.Position = Vector2.new(vector.X - size, vector.Y - size * 1.5)
                                esp.box.Color = boxColor
                                for _, line in ipairs(esp.boxLines) do line.Visible = false end
                            else
                                esp.box.Visible = false
                                pcall(draw3DBox, esp, hrp, camera, boxColor, boxSize)
                            end
                        else
                            esp.box.Visible = false
                            for _, line in ipairs(esp.boxLines) do line.Visible = false end
                        end

                        esp.tracer.Visible = toggles.tracers
                        if toggles.tracers then
                            esp.tracer.From = screenBottomCenter
                            esp.tracer.To = Vector2.new(vector.X, vector.Y)
                            esp.tracer.Color = toggles.rainbowTracers and Color3.fromHSV((tick() % 5) / 5, 1, 1) or Color3.fromRGB(0, 255, 0)
                        end

                        esp.name.Visible = toggles.names
                        if toggles.names then
                            esp.name.Text = model.Name
                            esp.name.Position = Vector2.new(vector.X, vector.Y - size * 1.5 - 20)
                            esp.name.Color = Color3.fromRGB(255, 255, 255)
                        end

                        esp.distance.Visible = toggles.distance
                        if toggles.distance then
                            local distance = getDistanceFromPlayer(hrp.Position)
                            esp.distance.Text = string.format("%.1f", distance)
                            esp.distance.Position = Vector2.new(vector.X, vector.Y + size * 1.5 + 5)
                            esp.distance.Color = Color3.fromRGB(255, 255, 255)
                        end
                    else
                        esp.box.Visible = false
                        esp.tracer.Visible = false
                        esp.name.Visible = false
                        esp.distance.Visible = false
                        for _, line in ipairs(esp.boxLines) do line.Visible = false end
                    end
                end
            end
        end
    end

    for target, esp in pairs(playerEspElements) do
        if not currentTargets[target] then
            cleanupDrawingTable(esp)
            playerEspElements[target] = nil
        end
    end
end

function updateNextbotESP()
    local camera = workspace.CurrentCamera
    if not camera then return end
    
    local screenBottomCenter = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y)
    local currentTargets = {}

    local gameFolder = workspace:FindFirstChild("Game")
    if gameFolder and gameFolder:FindFirstChild("Players") then
        for _, model in pairs(gameFolder.Players:GetChildren()) do
            if model:IsA("Model") and model:FindFirstChild("HumanoidRootPart") and isNextbotModel(model) then
                processNextbotModel(model, currentTargets, camera, screenBottomCenter)
            end
        end
    end

    if workspace:FindFirstChild("NPCs") then
        for _, model in pairs(workspace.NPCs:GetChildren()) do
            if model:IsA("Model") and model:FindFirstChild("HumanoidRootPart") and isNextbotModel(model) then
                processNextbotModel(model, currentTargets, camera, screenBottomCenter)
            end
        end
    end

    for target, esp in pairs(nextbotEspElements) do
        if not currentTargets[target] then
            cleanupDrawingTable(esp)
            nextbotEspElements[target] = nil
        end
    end
end

function processNextbotModel(model, currentTargets, camera, screenBottomCenter)
    currentTargets[model] = true
    
    if not nextbotEspElements[model] then
        nextbotEspElements[model] = createESPObject()
        setupESPObject(nextbotEspElements[model])
    end

    local esp = nextbotEspElements[model]
    local hrp = model.HumanoidRootPart
    local vector, onScreen = camera:WorldToViewportPoint(hrp.Position)

    if onScreen then
        local topY = camera:WorldToViewportPoint(hrp.Position + Vector3.new(0, 3, 0)).Y
        local bottomY = camera:WorldToViewportPoint(hrp.Position - Vector3.new(0, 3, 0)).Y
        local size = (bottomY - topY) / 2
        local toggles = featureStates.NextbotESP
        local humanoid = model:FindFirstChild("Humanoid")
        local boxSize = humanoid and Vector3.new(2, humanoid.HipHeight + 5, 2) or Vector3.new(4, 5, 3)

        if toggles.boxes then
            local boxColor = toggles.rainbowBoxes and Color3.fromHSV((tick() % 5) / 5, 1, 1) or Color3.fromRGB(255, 0, 0)
            if toggles.boxType == "2D" then
                esp.box.Visible = true
                esp.box.Size = Vector2.new(size * 2, size * 3)
                esp.box.Position = Vector2.new(vector.X - size, vector.Y - size * 1.5)
                esp.box.Color = boxColor
                for _, line in ipairs(esp.boxLines) do line.Visible = false end
            else
                esp.box.Visible = false
                pcall(draw3DBox, esp, hrp, camera, boxColor, boxSize)
            end
        else
            esp.box.Visible = false
            for _, line in ipairs(esp.boxLines) do line.Visible = false end
        end

        esp.tracer.Visible = toggles.tracers
        if toggles.tracers then
            esp.tracer.From = screenBottomCenter
            esp.tracer.To = Vector2.new(vector.X, vector.Y)
            esp.tracer.Color = toggles.rainbowTracers and Color3.fromHSV((tick() % 5) / 5, 1, 1) or Color3.fromRGB(255, 0, 0)
        end

        esp.name.Visible = toggles.names
        if toggles.names then
            esp.name.Text = model.Name
            esp.name.Position = Vector2.new(vector.X, vector.Y - size * 1.5 - 20)
            esp.name.Color = Color3.fromRGB(255, 0, 0)
        end

        esp.distance.Visible = toggles.distance
        if toggles.distance then
            local distance = getDistanceFromPlayer(hrp.Position)
            esp.distance.Text = string.format("%.1f", distance)
            esp.distance.Position = Vector2.new(vector.X, vector.Y + size * 1.5 + 5)
            esp.distance.Color = Color3.fromRGB(255, 0, 0)
        end
    else
        esp.box.Visible = false
        esp.tracer.Visible = false
        esp.name.Visible = false
        esp.distance.Visible = false
        for _, line in ipairs(esp.boxLines) do line.Visible = false end
    end
end

function startPlayerESP()
    if playerEspConnection then return end
    playerEspConnection = RunService.RenderStepped:Connect(updatePlayerESP)
end

function stopPlayerESP()
    if playerEspConnection then
        playerEspConnection:Disconnect()
        playerEspConnection = nil
    end
    for _, esp in pairs(playerEspElements) do
        cleanupDrawingTable(esp)
    end
    playerEspElements = {}
end

function startNextbotESP()
    if nextbotEspConnection then return end
    nextbotEspConnection = RunService.RenderStepped:Connect(updateNextbotESP)
end

function stopNextbotESP()
    if nextbotEspConnection then
        nextbotEspConnection:Disconnect()
        nextbotEspConnection = nil
    end
    for _, esp in pairs(nextbotEspElements) do
        cleanupDrawingTable(esp)
    end
    nextbotEspElements = {}
end

function setupNextbotDetection()
    local gameFolder = workspace:FindFirstChild("Game")
    if gameFolder and gameFolder:FindFirstChild("Players") then
        gameFolder.Players.ChildAdded:Connect(function(child)
            if child:IsA("Model") and isNextbotModel(child) then
                task.wait(0.5)
                updateNextbotESP()
            end
        end)
    end
    if workspace:FindFirstChild("NPCs") then
        workspace.NPCs.ChildAdded:Connect(function(child)
            if child:IsA("Model") and isNextbotModel(child) then
                task.wait(0.5)
                updateNextbotESP()
            end
        end)
    end
end

function startDownedTracer()
    downedTracerConnection = RunService.Heartbeat:Connect(function()
        cleanupTracers(downedTracerLines)
        downedTracerLines = {}
        local folder = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Players")
        if folder then
            for _, char in ipairs(folder:GetChildren()) do
                if char:IsA("Model") then
                    local team = char:GetAttribute("Team")
                    local downed = char:GetAttribute("Downed")
                    if team ~= "Nextbot" and char.Name ~= player.Name and downed == true then
                        local hrp = char:FindFirstChild("HumanoidRootPart")
                        if hrp and workspace.CurrentCamera then
                            local pos, onScreen = workspace.CurrentCamera:WorldToViewportPoint(hrp.Position)
                            if onScreen then
                                if featureStates.DownedTracer then
                                    local tracer = Drawing.new("Line")
                                    tracer.Color = Color3.fromRGB(255, 165, 0)
                                    tracer.Thickness = 2
                                    tracer.From = Vector2.new(workspace.CurrentCamera.ViewportSize.X / 2, workspace.CurrentCamera.ViewportSize.Y)
                                    tracer.To = Vector2.new(pos.X, pos.Y)
                                    tracer.ZIndex = 1
                                    tracer.Visible = true
                                    table.insert(downedTracerLines, tracer)
                                end
                            end
                        end
                    end
                end
            end
        end
    end)
end

function stopDownedTracer()
    if downedTracerConnection then
        downedTracerConnection:Disconnect()
        downedTracerConnection = nil
    end
    cleanupTracers(downedTracerLines)
    downedTracerLines = {}
end

function startDownedNameESP()
    downedNameESPConnection = RunService.Heartbeat:Connect(function()
        cleanupNameESPLabels(downedNameESPLabels)
        downedNameESPLabels = {}
        local folder = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Players")
        if folder then
            for _, char in ipairs(folder:GetChildren()) do
                if char:IsA("Model") then
                    local team = char:GetAttribute("Team")
                    local downed = char:GetAttribute("Downed")
                    if team ~= "Nextbot" and char.Name ~= player.Name and downed == true then
                        local hrp = char:FindFirstChild("HumanoidRootPart")
                        if hrp and workspace.CurrentCamera then
                            local pos, onScreen = workspace.CurrentCamera:WorldToViewportPoint(hrp.Position)
                            if onScreen then
                                local distance = getDistanceFromPlayer(hrp.Position)
                                local displayText = char.Name
                                if featureStates.DownedDistanceESP then
                                    displayText = displayText .. "\n" .. math.floor(distance) .. " studs"
                                end
                                local label = Drawing.new("Text")
                                label.Text = displayText
                                label.Size = 16
                                label.Center = true
                                label.Outline = true
                                label.OutlineColor = Color3.new(0, 0, 0)
                                label.Color = Color3.fromRGB(255, 165, 0)
                                label.Position = Vector2.new(pos.X, pos.Y - 50)
                                label.Visible = true
                                table.insert(downedNameESPLabels, label)
                            end
                        end
                    end
                end
            end
        end
    end)
end

function stopDownedNameESP()
    if downedNameESPConnection then
        downedNameESPConnection:Disconnect()
        downedNameESPConnection = nil
    end
    cleanupNameESPLabels(downedNameESPLabels)
    downedNameESPLabels = {}
end

Tabs.ESP:Section({ Title = "ESP", TextSize = 40 })
Tabs.ESP:Section({ Title = "Note: Enabling this higher amount Nextbot Player and ticket may coust your game to lag", TextSize = 10 })
Tabs.ESP:Divider()

Tabs.ESP:Section({ Title = "Player ESP" })

PlayerNameESPToggle = Tabs.ESP:Toggle({
    Title = "loc:PLAYER_NAME_ESP",
    Value = false,
    Callback = function(state)
        featureStates.PlayerESP.names = state
        if state or featureStates.PlayerESP.boxes or featureStates.PlayerESP.tracers or featureStates.PlayerESP.distance then
            startPlayerESP()
        else
            stopPlayerESP()
        end
    end
})

PlayerBoxESPToggle = Tabs.ESP:Toggle({
    Title = "loc:PLAYER_BOX_ESP",
    Value = false,
    Callback = function(state)
        featureStates.PlayerESP.boxes = state
        if state or featureStates.PlayerESP.tracers or featureStates.PlayerESP.names or featureStates.PlayerESP.distance then
            startPlayerESP()
        else
            stopPlayerESP()
        end
    end
})

PlayerBoxTypeDropdown = Tabs.ESP:Dropdown({
    Title = "Player Box Type",
    Values = {"2D", "3D"},
    Value = "2D",
    Callback = function(value)
        featureStates.PlayerESP.boxType = value
    end
})

PlayerRainbowBoxesToggle = Tabs.ESP:Toggle({
    Title = "loc:PLAYER_RAINBOW_BOXES",
    Value = false,
    Callback = function(state)
        featureStates.PlayerESP.rainbowBoxes = state
        if featureStates.PlayerESP.boxes then
            stopPlayerESP()
            startPlayerESP()
        end
    end
})

PlayerTracerToggle = Tabs.ESP:Toggle({
    Title = "loc:PLAYER_TRACER",
    Value = false,
    Callback = function(state)
        featureStates.PlayerESP.tracers = state
        if state or featureStates.PlayerESP.boxes or featureStates.PlayerESP.names or featureStates.PlayerESP.distance then
            startPlayerESP()
        else
            stopPlayerESP()
        end
    end
})

PlayerRainbowTracersToggle = Tabs.ESP:Toggle({
    Title = "loc:PLAYER_RAINBOW_TRACERS",
    Value = false,
    Callback = function(state)
        featureStates.PlayerESP.rainbowTracers = state
        if featureStates.PlayerESP.tracers then
            stopPlayerESP()
            startPlayerESP()
        end
    end
})

PlayerDistanceESPToggle = Tabs.ESP:Toggle({
    Title = "loc:PLAYER_DISTANCE_ESP",
    Value = false,
    Callback = function(state)
        featureStates.PlayerESP.distance = state
        if state or featureStates.PlayerESP.boxes or featureStates.PlayerESP.tracers or featureStates.PlayerESP.names then
            startPlayerESP()
        else
            stopPlayerESP()
        end
    end
})

PlayerHighlightsToggle = Tabs.ESP:Toggle({
    Title = "Player Highlights ESP",
    Value = false,
    Callback = function(state)
        PlayerHighlightsToggle = state
        if state then
            startPlayerHighlights()
        else
            stopPlayerHighlights()
        end
    end
})

Tabs.ESP:Section({ Title = "Nextbot Name ESP" })

NextbotESPToggle = Tabs.ESP:Toggle({
    Title = "loc:NEXTBOT_NAME_ESP",
    Value = false,
    Callback = function(state)
        featureStates.NextbotESP.names = state
        if state then
            startNextbotESP()
            setupNextbotDetection()
        else
            stopNextbotESP()
        end
    end
})

NextbotBoxESPToggle = Tabs.ESP:Toggle({
    Title = "Nextbot Box ESP",
    Value = false,
    Callback = function(state)
        featureStates.NextbotESP.boxes = state
        if state or featureStates.NextbotESP.names or featureStates.NextbotESP.tracers or featureStates.NextbotESP.distance then
            startNextbotESP()
        else
            stopNextbotESP()
        end
    end
})

NextbotBoxTypeDropdown = Tabs.ESP:Dropdown({
    Title = "Nextbot Box Type",
    Values = {"2D", "3D"},
    Value = "2D",
    Callback = function(value)
        featureStates.NextbotESP.boxType = value
    end
})

NextbotRainbowBoxesToggle = Tabs.ESP:Toggle({
    Title = "Nextbot Rainbow Boxes",
    Value = false,
    Callback = function(state)
        featureStates.NextbotESP.rainbowBoxes = state
        if featureStates.NextbotESP.boxes then
            stopNextbotESP()
            startNextbotESP()
        end
    end
})

NextbotTracerToggle = Tabs.ESP:Toggle({
    Title = "Nextbot Tracer",
    Value = false,
    Callback = function(state)
        featureStates.NextbotESP.tracers = state
        if state or featureStates.NextbotESP.names or featureStates.NextbotESP.boxes or featureStates.NextbotESP.distance then
            startNextbotESP()
        else
            stopNextbotESP()
        end
    end
})

NextbotRainbowTracersToggle = Tabs.ESP:Toggle({
    Title = "Nextbot Rainbow Tracers",
    Value = false,
    Callback = function(state)
        featureStates.NextbotESP.rainbowTracers = state
        if featureStates.NextbotESP.tracers then
            stopNextbotESP()
            startNextbotESP()
        end
    end
})

NextbotDistanceESPToggle = Tabs.ESP:Toggle({
    Title = "Nextbot Distance ESP",
    Value = false,
    Callback = function(state)
        featureStates.NextbotESP.distance = state
        if state or featureStates.NextbotESP.names or featureStates.NextbotESP.boxes or featureStates.NextbotESP.tracers then
            startNextbotESP()
        else
            stopNextbotESP()
        end
    end
})

Tabs.ESP:Section({ Title = "Downed Player ESP" })

DownedBoxESPToggle = Tabs.ESP:Toggle({
    Title = "loc:DOWNED_BOX_ESP",
    Value = false,
    Callback = function(state)
        featureStates.DownedBoxESP = state
        if state or featureStates.DownedTracer then
            if downedTracerConnection then stopDownedTracer() end
            startDownedTracer()
        else
            stopDownedTracer()
        end
    end
})

DownedBoxTypeDropdown = Tabs.ESP:Dropdown({
    Title = "Downed Box Type",
    Values = {"2D", "3D"},
    Value = "2D",
    Callback = function(value)
        featureStates.DownedBoxType = value
    end
})

DownedTracerToggle = Tabs.ESP:Toggle({
    Title = "loc:DOWNED_TRACER",
    Value = false,
    Callback = function(state)
        featureStates.DownedTracer = state
        if state or featureStates.DownedBoxESP then
            if downedTracerConnection then stopDownedTracer() end
            startDownedTracer()
        else
            stopDownedTracer()
        end
    end
})

DownedNameESPToggle = Tabs.ESP:Toggle({
    Title = "loc:DOWNED_NAME_ESP",
    Value = false,
    Callback = function(state)
        featureStates.DownedNameESP = state
        if state then
            startDownedNameESP()
        else
            stopDownedNameESP()
        end
    end
})

DownedDistanceESPToggle = Tabs.ESP:Toggle({
    Title = "loc:DOWNED_DISTANCE_ESP",
    Value = false,
    Callback = function(state)
        featureStates.DownedDistanceESP = state
        if featureStates.DownedNameESP then
            stopDownedNameESP()
            startDownedNameESP()
        end
    end
})
PlayerHighlights = {}
DownedHighlights = {}
PlayerHighlightsToggle = false
DownedHighlightsToggle = false

function updatePlayerHighlights()
    for target, highlight in pairs(PlayerHighlights) do
        highlight:Destroy()
    end
    PlayerHighlights = {}
    
    local gameFolder = workspace:FindFirstChild("Game")
    if not gameFolder or not gameFolder:FindFirstChild("Players") then return end
    
    for _, model in pairs(gameFolder.Players:GetChildren()) do
        if model:IsA("Model") and model:FindFirstChild("HumanoidRootPart") then
            local isPlayer = Players:GetPlayerFromCharacter(model) ~= nil
            local humanoid = model:FindFirstChild("Humanoid")
            
            if isPlayer and model.Name ~= player.Name and humanoid and humanoid.Health > 0 then
                local highlight = Instance.new("Highlight")
                highlight.Name = "PlayerHighlight"
                highlight.Adornee = model
                highlight.FillColor = Color3.fromRGB(0, 255, 0)
                highlight.OutlineColor = Color3.fromRGB(0, 200, 0)
                highlight.FillTransparency = 0.5
                highlight.OutlineTransparency = 0
                highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                highlight.Parent = model
                PlayerHighlights[model] = highlight
            end
        end
    end
end

function startPlayerHighlights()
    if PlayerHighlightsConnection then 
        PlayerHighlightsConnection:Disconnect()
    end
    PlayerHighlightsConnection = RunService.Heartbeat:Connect(function()
        updatePlayerHighlights()
    end)
end

function stopPlayerHighlights()
    if PlayerHighlightsConnection then
        PlayerHighlightsConnection:Disconnect()
        PlayerHighlightsConnection = nil
    end
    for target, highlight in pairs(PlayerHighlights) do
        highlight:Destroy()
    end
    PlayerHighlights = {}
end

function updateDownedHighlights()
    for target, highlight in pairs(DownedHighlights) do
        highlight:Destroy()
    end
    DownedHighlights = {}
    
    local folder = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Players")
    if not folder then return end
    
    for _, char in ipairs(folder:GetChildren()) do
        if char:IsA("Model") then
            local team = char:GetAttribute("Team")
            local downed = char:GetAttribute("Downed")
            local hrp = char:FindFirstChild("HumanoidRootPart")
            
            if team ~= "Nextbot" and char.Name ~= player.Name and downed == true and hrp then
                local highlight = Instance.new("Highlight")
                highlight.Name = "DownedHighlight"
                highlight.Adornee = char
                highlight.FillColor = Color3.fromRGB(255, 165, 0)
                highlight.OutlineColor = Color3.fromRGB(200, 120, 0)
                highlight.FillTransparency = 0.5
                highlight.OutlineTransparency = 0
                highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                highlight.Parent = char
                DownedHighlights[char] = highlight
            end
        end
    end
end

function startDownedHighlights()
    if DownedHighlightsConnection then 
        DownedHighlightsConnection:Disconnect()
    end
    DownedHighlightsConnection = RunService.Heartbeat:Connect(function()
        updateDownedHighlights()
    end)
end

function stopDownedHighlights()
    if DownedHighlightsConnection then
        DownedHighlightsConnection:Disconnect()
        DownedHighlightsConnection = nil
    end
    for target, highlight in pairs(DownedHighlights) do
        highlight:Destroy()
    end
    DownedHighlights = {}
end

DownedHighlightsToggle = Tabs.ESP:Toggle({
    Title = "Downed Highlights ESP",
    Value = false,
    Callback = function(state)
        DownedHighlightsToggle = state
        if state then
            startDownedHighlights()
        else
            stopDownedHighlights()
        end
    end
})
Tabs.ESP:Section({ Title = "Ticket ESP" })
local function cleanupDrawings(drawingTable)
    for ticket, drawings in pairs(drawingTable or {}) do
        pcall(function()
            if drawings and type(drawings) == "table" then
                for _, drawing in ipairs(drawings) do
                    if drawing and drawing.Remove then
                        drawing:Remove()
                    end
                end
            elseif drawings and drawings.Remove then
                drawings:Remove()
            end
        end)
        drawingTable[ticket] = nil
    end
    return {}
end

local function cleanupHighlights(highlightTable)
    for _, highlight in pairs(highlightTable or {}) do
        pcall(function()
            if highlight and highlight.Destroy then
                highlight:Destroy()
            end
        end)
    end
    return {}
end

TicketEspToggle = Tabs.ESP:Toggle({
    Title = "Ticket ESP",
    Value = false,
    Callback = function(state)
        if not state then
            if getgenv().ticketEspConnections then
                for _, connection in ipairs(getgenv().ticketEspConnections) do
                    connection:Disconnect()
                end
                getgenv().ticketEspConnections = nil
                task.wait(0.5)
                if getgenv().ticketEspLabels then
                    getgenv().ticketEspLabels = cleanupDrawings(getgenv().ticketEspLabels)
                end
            end
            return
        end

        getgenv().ticketEspConnections = getgenv().ticketEspConnections or {}
        getgenv().ticketEspLabels = getgenv().ticketEspLabels or {}
        
        for _, connection in ipairs(getgenv().ticketEspConnections) do
            connection:Disconnect()
        end
        getgenv().ticketEspConnections = {}
        getgenv().ticketEspLabels = cleanupDrawings(getgenv().ticketEspLabels)

        local tickets = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Effects") and workspace.Game.Effects:FindFirstChild("Tickets")
        if not tickets then return end

        local function updateEsp()
            if not tickets then return end
            
            for ticket, label in pairs(getgenv().ticketEspLabels) do
                if not ticket.Parent or not ticket:FindFirstChild("HumanoidRootPart") then
                    label:Remove()
                    getgenv().ticketEspLabels[ticket] = nil
                end
            end
            
            for _, ticket in ipairs(tickets:GetChildren()) do
                if ticket:FindFirstChild("HumanoidRootPart") and not getgenv().ticketEspLabels[ticket] then
                    local label = Drawing.new("Text")
                    label.Visible = false
                    label.Text = "Ticket"
                    label.Color = Color3.fromRGB(0, 0, 255)
                    label.Size = 20
                    label.Center = true
                    label.Outline = true
                    getgenv().ticketEspLabels[ticket] = label
                end
            end
            
            local camera = workspace.CurrentCamera
            if not camera then return end
            for ticket, label in pairs(getgenv().ticketEspLabels) do
                local ticketPart = ticket:FindFirstChild("HumanoidRootPart")
                if ticketPart then
                    local screenPos, onScreen = camera:WorldToViewportPoint(ticketPart.Position)
                    label.Visible = onScreen
                    if onScreen then
                        label.Position = Vector2.new(screenPos.X, screenPos.Y - 30)
                    end
                end
            end
        end
        
        task.spawn(updateEsp)
        
        table.insert(getgenv().ticketEspConnections, RunService.RenderStepped:Connect(function()
            task.spawn(updateEsp)
        end))
        table.insert(getgenv().ticketEspConnections, tickets.ChildAdded:Connect(updateEsp))
        table.insert(getgenv().ticketEspConnections, tickets.ChildRemoved:Connect(updateEsp))
    end
})

TicketTracerEspToggle = Tabs.ESP:Toggle({
    Title = "Ticket Tracer ESP",
    Value = false,
    Callback = function(state)
        if not state then
            if getgenv().ticketTracerConnections then
                for _, connection in ipairs(getgenv().ticketTracerConnections) do
                    connection:Disconnect()
                end
                getgenv().ticketTracerConnections = nil
                task.wait(0.5)
                if getgenv().ticketTracerDrawings then
                    getgenv().ticketTracerDrawings = cleanupDrawings(getgenv().ticketTracerDrawings)
                end
            end
            return
        end

        getgenv().ticketTracerConnections = getgenv().ticketTracerConnections or {}
        getgenv().ticketTracerDrawings = getgenv().ticketTracerDrawings or {}
        
        for _, connection in ipairs(getgenv().ticketTracerConnections) do
            connection:Disconnect()
        end
        getgenv().ticketTracerConnections = {}
        getgenv().ticketTracerDrawings = cleanupDrawings(getgenv().ticketTracerDrawings)

        local tickets = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Effects") and workspace.Game.Effects:FindFirstChild("Tickets")
        if not tickets then return end

        local function updateTracerEsp()
            if not tickets then return end
            
            for ticket, drawings in pairs(getgenv().ticketTracerDrawings) do
                if not ticket.Parent or not ticket:FindFirstChild("HumanoidRootPart") then
                    cleanupDrawings({[ticket] = drawings})
                    getgenv().ticketTracerDrawings[ticket] = nil
                end
            end
            
            for _, ticket in ipairs(tickets:GetChildren()) do
                if ticket:FindFirstChild("HumanoidRootPart") and not getgenv().ticketTracerDrawings[ticket] then
                    local tracer = Drawing.new("Line")
                    tracer.Visible = false
                    tracer.Color = Color3.fromRGB(0, 0, 255)
                    tracer.Thickness = 2
                    tracer.Transparency = 1
                    getgenv().ticketTracerDrawings[ticket] = {tracer}
                end
            end
            
            local camera = workspace.CurrentCamera
            if not camera then return end
            local screenBottomCenter = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y)
            for ticket, drawings in pairs(getgenv().ticketTracerDrawings) do
                local ticketPart = ticket:FindFirstChild("HumanoidRootPart")
                if ticketPart then
                    local screenPos, onScreen = camera:WorldToViewportPoint(ticketPart.Position)
                    drawings[1].Visible = onScreen
                    if onScreen then
                        drawings[1].From = screenBottomCenter
                        drawings[1].To = Vector2.new(screenPos.X, screenPos.Y)
                    end
                end
            end
        end
        
        task.spawn(updateTracerEsp)
        
        table.insert(getgenv().ticketTracerConnections, RunService.RenderStepped:Connect(function()
            task.spawn(updateTracerEsp)
        end))
        table.insert(getgenv().ticketTracerConnections, tickets.ChildAdded:Connect(updateTracerEsp))
        table.insert(getgenv().ticketTracerConnections, tickets.ChildRemoved:Connect(updateTracerEsp))
    end
})

TicketDistanceEspToggle = Tabs.ESP:Toggle({
    Title = "Ticket Distance ESP",
    Value = false,
    Callback = function(state)
        if not state then
            if getgenv().ticketDistanceConnections then
                for _, connection in ipairs(getgenv().ticketDistanceConnections) do
                    connection:Disconnect()
                end
                getgenv().ticketDistanceConnections = nil
                task.wait(0.5)
                if getgenv().ticketDistanceLabels then
                    getgenv().ticketDistanceLabels = cleanupDrawings(getgenv().ticketDistanceLabels)
                end
            end
            return
        end

        getgenv().ticketDistanceConnections = getgenv().ticketDistanceConnections or {}
        getgenv().ticketDistanceLabels = getgenv().ticketDistanceLabels or {}
        
        for _, connection in ipairs(getgenv().ticketDistanceConnections) do
            connection:Disconnect()
        end
        getgenv().ticketDistanceConnections = {}
        getgenv().ticketDistanceLabels = cleanupDrawings(getgenv().ticketDistanceLabels)

        local tickets = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Effects") and workspace.Game.Effects:FindFirstChild("Tickets")
        if not tickets then return end

        local function updateDistanceEsp()
            if not tickets then return end
            
            for ticket, label in pairs(getgenv().ticketDistanceLabels) do
                if not ticket.Parent or not ticket:FindFirstChild("HumanoidRootPart") then
                    label:Remove()
                    getgenv().ticketDistanceLabels[ticket] = nil
                end
            end
            
            for _, ticket in ipairs(tickets:GetChildren()) do
                if ticket:FindFirstChild("HumanoidRootPart") and not getgenv().ticketDistanceLabels[ticket] then
                    local distanceLabel = Drawing.new("Text")
                    distanceLabel.Visible = false
                    distanceLabel.Text = "0m"
                    distanceLabel.Color = Color3.fromRGB(0, 0, 255)
                    distanceLabel.Size = 16
                    distanceLabel.Center = true
                    distanceLabel.Outline = true
                    getgenv().ticketDistanceLabels[ticket] = distanceLabel
                end
            end
            
            local character = player.Character
            local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
            local camera = workspace.CurrentCamera
            if not camera or not humanoidRootPart then return end
            for ticket, label in pairs(getgenv().ticketDistanceLabels) do
                local ticketPart = ticket:FindFirstChild("HumanoidRootPart")
                if ticketPart then
                    local screenPos, onScreen = camera:WorldToViewportPoint(ticketPart.Position)
                    label.Visible = onScreen
                    if onScreen then
                        local distance = (ticketPart.Position - humanoidRootPart.Position).Magnitude
                        label.Text = string.format("%.1fm", distance)
                        label.Position = Vector2.new(screenPos.X, screenPos.Y + 20)
                    end
                end
            end
        end
        
        task.spawn(updateDistanceEsp)
        
        table.insert(getgenv().ticketDistanceConnections, RunService.RenderStepped:Connect(function()
            task.spawn(updateDistanceEsp)
        end))
        table.insert(getgenv().ticketDistanceConnections, tickets.ChildAdded:Connect(updateDistanceEsp))
        table.insert(getgenv().ticketDistanceConnections, tickets.ChildRemoved:Connect(updateDistanceEsp))
    end
})

HighlightsTicketEspToggle = Tabs.ESP:Toggle({
    Title = "Highlights Ticket ESP",
    Value = false,
    Callback = function(state)
        if not state then
            if getgenv().ticketHighlightConnections then
                for _, connection in ipairs(getgenv().ticketHighlightConnections) do
                    connection:Disconnect()
                end
                getgenv().ticketHighlightConnections = nil
                task.wait(0.5)
                if getgenv().ticketHighlights then
                    getgenv().ticketHighlights = cleanupHighlights(getgenv().ticketHighlights)
                end
            end
            return
        end

        getgenv().ticketHighlightConnections = getgenv().ticketHighlightConnections or {}
        getgenv().ticketHighlights = getgenv().ticketHighlights or {}
        
        for _, connection in ipairs(getgenv().ticketHighlightConnections) do
            connection:Disconnect()
        end
        getgenv().ticketHighlightConnections = {}
        getgenv().ticketHighlights = cleanupHighlights(getgenv().ticketHighlights)

        local tickets = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Effects") and workspace.Game.Effects:FindFirstChild("Tickets")
        if not tickets then return end

        local function updateHighlights()
            if not tickets then return end
            
            for ticket, highlight in pairs(getgenv().ticketHighlights) do
                if not ticket.Parent or not ticket:FindFirstChild("HumanoidRootPart") then
                    highlight:Destroy()
                    getgenv().ticketHighlights[ticket] = nil
                end
            end
            
            for _, ticket in ipairs(tickets:GetChildren()) do
                if ticket:FindFirstChild("HumanoidRootPart") and not getgenv().ticketHighlights[ticket] then
                    local highlight = Instance.new("Highlight")
                    highlight.Adornee = ticket
                    highlight.FillColor = Color3.fromRGB(0, 0, 255)
                    highlight.OutlineColor = Color3.fromRGB(0, 0, 255)
                    highlight.FillTransparency = 0.5
                    highlight.OutlineTransparency = 0
                    highlight.Parent = ticket
                    getgenv().ticketHighlights[ticket] = highlight
                end
            end
        end
        
        task.spawn(updateHighlights)
        
        table.insert(getgenv().ticketHighlightConnections, RunService.RenderStepped:Connect(function()
            task.spawn(updateHighlights)
        end))
        table.insert(getgenv().ticketHighlightConnections, tickets.ChildAdded:Connect(updateHighlights))
        table.insert(getgenv().ticketHighlightConnections, tickets.ChildRemoved:Connect(updateHighlights))
    end
})

TicketBoxEspToggle = Tabs.ESP:Toggle({
    Title = "Ticket Box ESP",
    Value = false,
    Callback = function(state)
        if not state then
            if getgenv().ticketBoxConnections then
                for _, connection in ipairs(getgenv().ticketBoxConnections) do
                    connection:Disconnect()
                end
                getgenv().ticketBoxConnections = nil
                task.wait(0.5)
                if getgenv().ticketBoxDrawings then
                    getgenv().ticketBoxDrawings = cleanupDrawings(getgenv().ticketBoxDrawings)
                end
            end
            return
        end

        getgenv().ticketBoxConnections = getgenv().ticketBoxConnections or {}
        getgenv().ticketBoxDrawings = getgenv().ticketBoxDrawings or {}
        
        for _, connection in ipairs(getgenv().ticketBoxConnections) do
            connection:Disconnect()
        end
        getgenv().ticketBoxConnections = {}
        getgenv().ticketBoxDrawings = cleanupDrawings(getgenv().ticketBoxDrawings)

        local tickets = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Effects") and workspace.Game.Effects:FindFirstChild("Tickets")
        if not tickets then return end

        local function updateBoxEsp()
            if not tickets then return end
            
            for ticket, drawings in pairs(getgenv().ticketBoxDrawings) do
                local is2D = type(drawings[1]) ~= "table"
                local expected2D = getgenv().ticketBoxType == "2D"
                if not ticket.Parent or not ticket:FindFirstChild("HumanoidRootPart") or is2D ~= expected2D then
                    cleanupDrawings({[ticket] = drawings})
                    getgenv().ticketBoxDrawings[ticket] = nil
                end
            end
            
            for _, ticket in ipairs(tickets:GetChildren()) do
                if ticket:FindFirstChild("HumanoidRootPart") and not getgenv().ticketBoxDrawings[ticket] then
                    local drawings = {}
                    if getgenv().ticketBoxType == "2D" then
                        local box = Drawing.new("Square")
                        box.Visible = false
                        box.Color = Color3.fromRGB(0, 0, 255)
                        box.Thickness = 2
                        box.Filled = false
                        drawings = {box}
                    else
                        drawings = {}
                        for i = 1, 12 do
                            local line = Drawing.new("Line")
                            line.Visible = false
                            line.Color = Color3.fromRGB(0, 0, 255)
                            line.Thickness = 2
                            line.Transparency = 1
                            table.insert(drawings, line)
                        end
                    end
                    getgenv().ticketBoxDrawings[ticket] = drawings
                end
            end
            
            local camera = workspace.CurrentCamera
            if not camera then return end
            for ticket, drawings in pairs(getgenv().ticketBoxDrawings) do
                local ticketPart = ticket:FindFirstChild("HumanoidRootPart")
                if ticketPart then
                    local screenPos, onScreen = camera:WorldToViewportPoint(ticketPart.Position)
                    if onScreen then
                        if getgenv().ticketBoxType == "2D" then
                            local topY = camera:WorldToViewportPoint(ticketPart.Position + Vector3.new(0, 2, 0)).Y
                            local bottomY = camera:WorldToViewportPoint(ticketPart.Position - Vector3.new(0, 2, 0)).Y
                            local size = (bottomY - topY) / 2
                            drawings[1].Size = Vector2.new(size * 2, size * 2)
                            drawings[1].Position = Vector2.new(screenPos.X - size, screenPos.Y - size)
                            drawings[1].Visible = true
                        else
                            local boxSize = Vector3.new(4, 4, 4)
                            local offsets = {
                                Vector3.new( boxSize.X/2,  boxSize.Y/2,  boxSize.Z/2),
                                Vector3.new( boxSize.X/2,  boxSize.Y/2, -boxSize.Z/2),
                                Vector3.new( boxSize.X/2, -boxSize.Y/2,  boxSize.Z/2),
                                Vector3.new( boxSize.X/2, -boxSize.Y/2, -boxSize.Z/2),
                                Vector3.new(-boxSize.X/2,  boxSize.Y/2,  boxSize.Z/2),
                                Vector3.new(-boxSize.X/2,  boxSize.Y/2, -boxSize.Z/2),
                                Vector3.new(-boxSize.X/2, -boxSize.Y/2,  boxSize.Z/2),
                                Vector3.new(-boxSize.X/2, -boxSize.Y/2, -boxSize.Z/2),
                            }
                            local screenPoints = {}
                            local anyPointOnScreen = false
                            for i, offset in ipairs(offsets) do
                                local worldPos = ticketPart.CFrame * offset
                                local vec, onScreenPoint = camera:WorldToViewportPoint(worldPos)
                                screenPoints[i] = {pos = Vector2.new(vec.X, vec.Y), depth = vec.Z}
                                if onScreenPoint and vec.Z > 0 then
                                    anyPointOnScreen = true
                                end
                            end
                            local edges = {
                                {1, 2}, {1, 3}, {1, 5},
                                {2, 4}, {2, 6},
                                {3, 4}, {3, 7},
                                {5, 6}, {5, 7},
                                {4, 8}, {6, 8}, {7, 8}
                            }
                            for i, edge in ipairs(edges) do
                                local line = drawings[i]
                                if line then
                                    local p1 = screenPoints[edge[1]]
                                    local p2 = screenPoints[edge[2]]
                                    if anyPointOnScreen and p1.depth > 0 and p2.depth > 0 then
                                        line.From = p1.pos
                                        line.To = p2.pos
                                        line.Visible = true
                                    else
                                        line.Visible = false
                                    end
                                end
                            end
                        end
                    else
                        for _, drawing in ipairs(drawings) do
                            drawing.Visible = false
                        end
                    end
                end
            end
        end
        
        task.spawn(updateBoxEsp)
        
        table.insert(getgenv().ticketBoxConnections, RunService.RenderStepped:Connect(function()
            task.spawn(updateBoxEsp)
        end))
        table.insert(getgenv().ticketBoxConnections, tickets.ChildAdded:Connect(updateBoxEsp))
        table.insert(getgenv().ticketBoxConnections, tickets.ChildRemoved:Connect(updateBoxEsp))
    end
})

BoxticketTypeDropdown = Tabs.ESP:Dropdown({
    Title = "Box Type",
    Values = {"2D", "3D"},
    Value = "2D",
    Callback = function(value)
        getgenv().ticketBoxType = value
        if getgenv().ticketBoxDrawings then
            getgenv().ticketBoxDrawings = cleanupDrawings(getgenv().ticketBoxDrawings)
        end
    end
})
    -- Auto Tab
    Tabs.Auto:Section({ Title = "Auto", TextSize = 40 })
    
     AutoJoin = Tabs.Auto:Toggle({
    Title = "Auto Join",
    Value = false,
    Callback = function(state)
        getgenv().AutoJoinEnabled = state
        
        if state then
            local Players = game:GetService("Players")
            local ReplicatedStorage = game:GetService("ReplicatedStorage")
            local LocalPlayer = Players.LocalPlayer

            local statsFolder = workspace:WaitForChild("Game"):WaitForChild("Stats")
            local hasRunThisRound = false
            local isExecuting = false

            local function isPlayerAlive()
                local character = LocalPlayer.Character
                if not character then return false end
                
                local humanoid = character:FindFirstChild("Humanoid")
                if not humanoid then return false end
                
                return humanoid.Health > 0
            end

            local function executeScript()
                if isExecuting then return end
                
                if isPlayerAlive() then
                    return
                end
                
                isExecuting = true
                
                local success = pcall(function()
                    game:GetService("ReplicatedStorage").Events.Player.ChangePlayerMode:FireServer(true)
                end)
                
                if success then
                    hasRunThisRound = true
                else
                    hasRunThisRound = false
                end
                
                isExecuting = false
            end

            local function checkTimerEnd()
                local timerValue = statsFolder:GetAttribute("Timer")
                local roundStarted = statsFolder:GetAttribute("RoundStarted")
                
                if timerValue == 0 and roundStarted == true then
                    if not hasRunThisRound then
                        executeScript()
                    end
                end
                
                if roundStarted == false then
                    hasRunThisRound = false
                end
            end

            local function onPlayerDied()
                if not hasRunThisRound then
                    executeScript()
                end
            end

            local function onGetLives()
                if not hasRunThisRound then
                    executeScript()
                end
            end

            getgenv().AutoJoinConnections = {
                timerConnection = statsFolder:GetAttributeChangedSignal("Timer"):Connect(checkTimerEnd),
                heartbeatConnection = game:GetService("RunService").Heartbeat:Connect(function()
                    local timerValue = statsFolder:GetAttribute("Timer")
                    local roundStarted = statsFolder:GetAttribute("RoundStarted")
                    
                    if timerValue == 0 and roundStarted == true and not hasRunThisRound then
                        executeScript()
                    end
                end),
                roundConnection = statsFolder:GetAttributeChangedSignal("RoundStarted"):Connect(function()
                    local roundStarted = statsFolder:GetAttribute("RoundStarted")
                    if roundStarted == false then
                        hasRunThisRound = false
                    end
                end)
            }

            getgenv().AutoJoinConnections.characterAddedConnection = LocalPlayer.CharacterAdded:Connect(function(character)
                local humanoid = character:WaitForChild("Humanoid")
                
                getgenv().AutoJoinConnections.humanoidDiedConnection = humanoid.Died:Connect(function()
                    local downed = character:GetAttribute("Downed")
                    if downed ~= true then
                        onPlayerDied()
                    end
                end)
            end)

            if LocalPlayer.Character then
                local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
                if humanoid then
                    getgenv().AutoJoinConnections.humanoidDiedConnection = humanoid.Died:Connect(function()
                        local downed = LocalPlayer.Character:GetAttribute("Downed")
                        if downed ~= true then
                            onPlayerDied()
                        end
                    end)
                end
            end

            getgenv().AutoJoinConnections.getLivesConnection = ReplicatedStorage.Events.Data.GetLives.OnClientEvent:Connect(function()
                onGetLives()
            end)

            task.spawn(function()
                local success = pcall(function()
                    ReplicatedStorage.Events.Data.GetLives:FireServer()
                end)
            end)

        else
            if getgenv().AutoJoinConnections then
                for name, connection in pairs(getgenv().AutoJoinConnections) do
                    if connection then
                        connection:Disconnect()
                    end
                end
                getgenv().AutoJoinConnections = nil
            end
        end
    end
})
getgenv().bhopMode = "Acceleration"
getgenv().bhopAccelValue = -0.5
getgenv().bhopHoldActive = false
getgenv().autoJumpEnabled = false
getgenv().jumpCooldown = 0.7
featureStates = featureStates or {}
featureStates.BhopGuiVisible = false
featureStates.Bhop = false
featureStates.BhopHold = false

local player = game:GetService("Players").LocalPlayer
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local Tabs = Tabs or {Auto = {}}

local isMobile = isMobile or UserInputService.TouchEnabled

local bhopConnection = nil
local bhopLoaded = false
local bhopKeyConnection = nil
local characterConnection = nil
local frictionTables = {}

local Character = nil
local Humanoid = nil
local HumanoidRootPart = nil
local LastJump = 0

local GROUND_CHECK_DISTANCE = 3.5
local MAX_SLOPE_ANGLE = 45
local AIR_RANGE = 0.1

local function findFrictionTables()
    frictionTables = {}
    for _, t in pairs(getgc(true)) do
        if type(t) == "table" and rawget(t, "Friction") then
            table.insert(frictionTables, {obj = t, original = t.Friction})
        end
    end
end

local function setFriction(value)
    for _, e in ipairs(frictionTables) do
        if e.obj and type(e.obj) == "table" and rawget(e.obj, "Friction") then
            e.obj.Friction = value
        end
    end
end

local function resetBhopFriction()
    for _, e in ipairs(frictionTables) do
        if e.obj and type(e.obj) == "table" and rawget(e.obj, "Friction") then
            e.obj.Friction = e.original
        end
    end
    frictionTables = {}
end

local function applyBhopFriction()
    if getgenv().bhopMode == "Acceleration" then
        findFrictionTables()
        if #frictionTables > 0 then
            setFriction(getgenv().bhopAccelValue or -0.5)
        end
    else
        resetBhopFriction()
    end
end

local function IsOnGround()
    if not Character or not HumanoidRootPart or not Humanoid then return false end

    local state = Humanoid:GetState()
    if state == Enum.HumanoidStateType.Jumping or 
       state == Enum.HumanoidStateType.Freefall or
       state == Enum.HumanoidStateType.Swimming then
        return false
    end

    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.FilterDescendantsInstances = {Character}
    raycastParams.IgnoreWater = true

    local rayOrigin = HumanoidRootPart.Position
    local rayDirection = Vector3.new(0, -GROUND_CHECK_DISTANCE, 0)
    local raycastResult = workspace:Raycast(rayOrigin, rayDirection, raycastParams)

    if not raycastResult then return false end

    local surfaceNormal = raycastResult.Normal
    local angle = math.deg(math.acos(surfaceNormal:Dot(Vector3.new(0, 1, 0))))

    return angle <= MAX_SLOPE_ANGLE
end

local function updateBhop()
    if not bhopLoaded then return end
    
    local character = player.Character
    local humanoid = character and character:FindFirstChild("Humanoid")
    if not character or not humanoid then
        return
    end

    local isBhopActive = getgenv().autoJumpEnabled or getgenv().bhopHoldActive

    if isBhopActive then
        local now = tick()
        if IsOnGround() and (now - LastJump) > getgenv().jumpCooldown then
            humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
            LastJump = now
        end
    end
end

local function loadBhop()
    if bhopLoaded then return end
    
    bhopLoaded = true
    
    if bhopConnection then
        bhopConnection:Disconnect()
    end
    bhopConnection = RunService.Heartbeat:Connect(updateBhop)
    applyBhopFriction()
end

local function unloadBhop()
    if not bhopLoaded then return end
    
    bhopLoaded = false
    
    if bhopConnection then
        bhopConnection:Disconnect()
        bhopConnection = nil
    end
    
    getgenv().bhopHoldActive = false
    resetBhopFriction()
end

local function checkBhopState()
    local shouldLoad = getgenv().autoJumpEnabled or getgenv().bhopHoldActive
    
    if shouldLoad then
        loadBhop()
    else
        unloadBhop()
    end
end

local function reapplyBhopOnRespawn()
    if getgenv().autoJumpEnabled or getgenv().bhopHoldActive then
        wait(0.5)
        applyBhopFriction()
        checkBhopState()
    end
end

local function makeDraggable(frame)
    frame.Active = true
    frame.Draggable = true
    
    local dragDetector = Instance.new("UIDragDetector")
    dragDetector.Parent = frame
    
    local originalBackground = frame.BackgroundColor3
    local originalTransparency = frame.BackgroundTransparency
    
    frame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            frame.BackgroundTransparency = originalTransparency - 0.1
        end
    end)
    
    frame.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            frame.BackgroundTransparency = originalTransparency
        end
    end)
end

local function setupBhopKeybind()
    if bhopKeyConnection then
        bhopKeyConnection:Disconnect()
    end
    
    bhopKeyConnection = UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
        if gameProcessedEvent then return end
        if input.KeyCode == Enum.KeyCode.B and featureStates.BhopGuiVisible then
            getgenv().autoJumpEnabled = not getgenv().autoJumpEnabled
            featureStates.Bhop = getgenv().autoJumpEnabled
            
            if BhopToggle then
                BhopToggle:Set(getgenv().autoJumpEnabled)
            end
            
            if jumpToggleBtn then
                jumpToggleBtn.Text = getgenv().autoJumpEnabled and "On" or "Off"
                jumpToggleBtn.BackgroundColor3 = getgenv().autoJumpEnabled and Color3.fromRGB(0, 120, 80) or Color3.fromRGB(120, 0, 0)
            end
            
            checkBhopState()
        end
    end)
end

local function setupJumpButton()
    local success, err = pcall(function()
        local touchGui = player:WaitForChild("PlayerGui", 5):WaitForChild("TouchGui", 5)
        if not touchGui then return end
        local touchControlFrame = touchGui:WaitForChild("TouchControlFrame", 5)
        if not touchControlFrame then return end
        local jumpButton = touchControlFrame:WaitForChild("JumpButton", 5)
        if not jumpButton then return end
        
        jumpButton.MouseButton1Down:Connect(function()
            if featureStates.BhopHold then
                getgenv().bhopHoldActive = true
                checkBhopState()
            end
        end)
        
        jumpButton.MouseButton1Up:Connect(function()
            getgenv().bhopHoldActive = false
            checkBhopState()
        end)
    end)
end

local function createBhopGui(yOffset)
    local bhopGuiOld = player.PlayerGui:FindFirstChild("BhopGui")
    if bhopGuiOld then bhopGuiOld:Destroy() end
    
    local bhopGui = Instance.new("ScreenGui")
    bhopGui.Name = "BhopGui"
    bhopGui.IgnoreGuiInset = true
    bhopGui.ResetOnSpawn = false
    bhopGui.Enabled = isMobile and featureStates.BhopGuiVisible or false
    bhopGui.Parent = player.PlayerGui

    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 60, 0, 60)
    frame.Position = UDim2.new(0.5, -30, 0.12 + (yOffset or 0), 0)
    frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    frame.BackgroundTransparency = 0.35
    frame.BorderSizePixel = 0
    frame.Parent = bhopGui
    
    makeDraggable(frame)

    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 6)
    corner.Parent = frame

    local stroke = Instance.new("UIStroke")
    stroke.Color = Color3.fromRGB(150, 150, 150)
    stroke.Thickness = 2
    stroke.Parent = frame

    local label = Instance.new("TextLabel")
    label.Text = "Bhop"
    label.Size = UDim2.new(0.9, 0, 0.5, 0)
    label.Position = UDim2.new(0.05, 0, 0, 0)
    label.BackgroundTransparency = 1
    label.TextColor3 = Color3.fromRGB(255, 255, 255)
    label.Font = Enum.Font.Roboto
    label.TextSize = 16
    label.TextXAlignment = Enum.TextXAlignment.Center
    label.TextYAlignment = Enum.TextYAlignment.Center
    label.TextScaled = true
    label.Parent = frame

    local bhopGuiButton = Instance.new("TextButton")
    bhopGuiButton.Name = "ToggleButton"
    bhopGuiButton.Text = getgenv().autoJumpEnabled and "On" or "Off"
    bhopGuiButton.Size = UDim2.new(0.9, 0, 0.5, 0)
    bhopGuiButton.Position = UDim2.new(0.05, 0, 0.5, 0)
    bhopGuiButton.BackgroundColor3 = getgenv().autoJumpEnabled and Color3.fromRGB(0, 120, 80) or Color3.fromRGB(120, 0, 0)
    bhopGuiButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    bhopGuiButton.Font = Enum.Font.Roboto
    bhopGuiButton.TextSize = 14
    bhopGuiButton.TextXAlignment = Enum.TextXAlignment.Center
    bhopGuiButton.TextYAlignment = Enum.TextYAlignment.Center
    bhopGuiButton.TextScaled = true
    bhopGuiButton.Parent = frame

    local buttonCorner = Instance.new("UICorner")
    buttonCorner.CornerRadius = UDim.new(0, 4)
    buttonCorner.Parent = bhopGuiButton

    bhopGuiButton.MouseButton1Click:Connect(function()
        getgenv().autoJumpEnabled = not getgenv().autoJumpEnabled
        featureStates.Bhop = getgenv().autoJumpEnabled
        bhopGuiButton.Text = getgenv().autoJumpEnabled and "On" or "Off"
        bhopGuiButton.BackgroundColor3 = getgenv().autoJumpEnabled and Color3.fromRGB(0, 120, 80) or Color3.fromRGB(120, 0, 0)
        
        if BhopToggle then
            BhopToggle:Set(getgenv().autoJumpEnabled)
        end
        
        checkBhopState()
    end)

    return bhopGui, bhopGuiButton
end

local jumpGui, jumpToggleBtn = createBhopGui(0.12)

setupJumpButton()
setupBhopKeybind()

RunService.Heartbeat:Connect(function()
    if not Character or not Character:IsDescendantOf(workspace) then
        Character = player.Character or player.CharacterAdded:Wait()
        if Character then
            Humanoid = Character:FindFirstChildOfClass("Humanoid")
            HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
        else
            Humanoid = nil
            HumanoidRootPart = nil
        end
    end
end)

if characterConnection then
    characterConnection:Disconnect()
end
characterConnection = player.CharacterAdded:Connect(function(character)
    Character = character
    Humanoid = character:WaitForChild("Humanoid")
    HumanoidRootPart = character:WaitForChild("HumanoidRootPart")
    setupJumpButton()
    reapplyBhopOnRespawn()
end)

BhopToggle = Tabs.Auto:Toggle({
    Title = "Bhop",
    Value = false,
    Callback = function(state)
        featureStates.Bhop = state
        getgenv().autoJumpEnabled = state
        
        if jumpGui and jumpToggleBtn then
            jumpToggleBtn.Text = state and "On" or "Off"
            jumpToggleBtn.BackgroundColor3 = state and Color3.fromRGB(0, 120, 80) or Color3.fromRGB(120, 0, 0)
            jumpGui.Enabled = isMobile and featureStates.BhopGuiVisible or false
        end
        
        checkBhopState()
    end
})

BhopHoldToggle = Tabs.Auto:Toggle({
    Title = "Bhop (Hold Space/Jump)",
    Value = false,
    Callback = function(state)
        featureStates.BhopHold = state
        if not state then
            getgenv().bhopHoldActive = false
            checkBhopState()
        end
    end
})

BhopShortcutToggle = Tabs.Auto:Toggle({
    Title = "Bhop Shortcut",
    Desc = "Show Bhop GUI For quick Toggle or press B to Toggle Bhop (Auto jump)",
    Value = false,
    Callback = function(state)
        featureStates.BhopGuiVisible = state
        if jumpGui then
            jumpGui.Enabled = isMobile and state or false
        end
        setupBhopKeybind()
    end
})

BhopModeDropdown = Tabs.Auto:Dropdown({
    Title = "Bhop Mode",
    Values = {"Acceleration", "No Acceleration"},
    Value = "Acceleration",
    Callback = function(value)
        getgenv().bhopMode = value
        checkBhopState()
    end
})

BhopAccelInput = Tabs.Auto:Input({
    Title = "Bhop Acceleration (Negative Only)",
    Placeholder = "-0.5",
    Numeric = true,
    Callback = function(value)
        if tostring(value):sub(1, 1) == "-" then
            local n = tonumber(value)
            if n then
                getgenv().bhopAccelValue = n
                if getgenv().autoJumpEnabled or getgenv().bhopHoldActive then
                    applyBhopFriction()
                end
            end
        end
    end
})

JumpCooldownInput = Tabs.Auto:Input({
    Title = "Jump Cooldown (Seconds)",
    Placeholder = "0.7",
    Numeric = true,
    Callback = function(value)
        local n = tonumber(value)
        if n and n > 0 then
            getgenv().jumpCooldown = n
        end
    end
})

UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if gameProcessedEvent then return end
    if input.KeyCode == Enum.KeyCode.Space and featureStates.BhopHold then
        getgenv().bhopHoldActive = true
        checkBhopState()
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.Space then
        getgenv().bhopHoldActive = false
        checkBhopState()
    end
end)

Players.PlayerRemoving:Connect(function(leavingPlayer)
    if leavingPlayer == player then
        unloadBhop()
        if jumpGui then
            jumpGui:Destroy()
        end
        if bhopKeyConnection then
            bhopKeyConnection:Disconnect()
        end
        if characterConnection then
            characterConnection:Disconnect()
        end
    end
end)

checkBhopState()

getgenv().crouchGuiVisible = false

local previousCrouchState = false
local spamDown = true
local crouchConnection = nil
local keybindConnection = nil
local guiInstance = nil

local function fireKeybind(down, key)
    local ohTable = {
        ["Down"] = down,
        ["Key"] = key
    }
    local event = game:GetService("Players").LocalPlayer:WaitForChild("PlayerScripts"):WaitForChild("Events"):WaitForChild("temporary_events"):WaitForChild("UseKeybind")
    event:Fire(ohTable)
end

local function makeDraggable(frame)
    frame.Active = true
    frame.Draggable = true
    
    local dragDetector = Instance.new("UIDragDetector")
    dragDetector.Parent = frame
    
    local originalBackground = frame.BackgroundColor3
    local originalTransparency = frame.BackgroundTransparency
    
    frame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            frame.BackgroundTransparency = originalTransparency - 0.1
        end
    end)
    
    frame.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            frame.BackgroundTransparency = originalTransparency
        end
    end)
end

local function createCrouchGui(yOffset)
    local crouchGuiOld = playerGui:FindFirstChild("CrouchGui")
    if crouchGuiOld then crouchGuiOld:Destroy() end
    
    local crouchGui = Instance.new("ScreenGui")
    crouchGui.Name = "CrouchGui"
    crouchGui.IgnoreGuiInset = true
    crouchGui.ResetOnSpawn = false
    crouchGui.Enabled = getgenv().crouchGuiVisible
    crouchGui.Parent = playerGui

    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 50, 0, 50)
    frame.Position = UDim2.new(0.5, -25, 0.12 + (yOffset or 0), 0)
    frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    frame.BackgroundTransparency = 0.35
    frame.BorderSizePixel = 0
    frame.Parent = crouchGui
    makeDraggable(frame)

    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 6)
    corner.Parent = frame

    local stroke = Instance.new("UIStroke")
    stroke.Color = Color3.fromRGB(150, 150, 150)
    stroke.Thickness = 2
    stroke.Parent = frame

    local label = Instance.new("TextLabel")
    label.Text = "Auto Crouch"
    label.Size = UDim2.new(0.9, 0, 0.6, 0)
    label.Position = UDim2.new(0.05, 0, 0, 0)
    label.BackgroundTransparency = 1
    label.TextColor3 = Color3.fromRGB(255, 255, 255)
    label.Font = Enum.Font.Roboto
    label.TextSize = 12
    label.TextXAlignment = Enum.TextXAlignment.Center
    label.TextYAlignment = Enum.TextYAlignment.Center
    label.TextScaled = true
    label.Parent = frame

    local crouchGuiButton = Instance.new("TextButton")
    crouchGuiButton.Name = "ToggleButton"
    crouchGuiButton.Text = featureStates.AutoCrouch and "On" or "Off"
    crouchGuiButton.Size = UDim2.new(0.9, 0, 0.4, 0)
    crouchGuiButton.Position = UDim2.new(0.05, 0, 0.6, 0)
    crouchGuiButton.BackgroundColor3 = featureStates.AutoCrouch and Color3.fromRGB(0, 120, 80) or Color3.fromRGB(120, 0, 0)
    crouchGuiButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    crouchGuiButton.Font = Enum.Font.Roboto
    crouchGuiButton.TextSize = 12
    crouchGuiButton.TextXAlignment = Enum.TextXAlignment.Center
    crouchGuiButton.TextYAlignment = Enum.TextYAlignment.Center
    crouchGuiButton.TextScaled = true
    crouchGuiButton.Parent = frame

    local buttonCorner = Instance.new("UICorner")
    buttonCorner.CornerRadius = UDim.new(0, 4)
    buttonCorner.Parent = crouchGuiButton

    crouchGuiButton.MouseButton1Click:Connect(function()
        featureStates.AutoCrouch = not featureStates.AutoCrouch
        crouchGuiButton.Text = featureStates.AutoCrouch and "On" or "Off"
        crouchGuiButton.BackgroundColor3 = featureStates.AutoCrouch and Color3.fromRGB(0, 120, 80) or Color3.fromRGB(120, 0, 0)
    end)

    guiInstance = crouchGui
end

-- Setup persistent listeners (always running, but gated by feature state or visibility)
local function setupAutoCrouchListeners()
    if crouchConnection then crouchConnection:Disconnect() end
    crouchConnection = RunService.Heartbeat:Connect(function()
        if not featureStates.AutoCrouch then return end
        local character = Players.LocalPlayer.Character
        if not character or not character:FindFirstChild("Humanoid") then return end

        local humanoid = character.Humanoid
        local mode = featureStates.AutoCrouchMode

        if mode == "Normal" then
            fireKeybind(spamDown, "Crouch")
            spamDown = not spamDown
        else
            local isAir = (humanoid.FloorMaterial == Enum.Material.Air) and (humanoid:GetState() ~= Enum.HumanoidStateType.Seated)
            local shouldCrouch = (mode == "Air" and isAir) or (mode == "Ground" and not isAir)
            if shouldCrouch ~= previousCrouchState then
                fireKeybind(shouldCrouch, "Crouch")
                previousCrouchState = shouldCrouch
            end
        end
    end)

    if keybindConnection then keybindConnection:Disconnect() end
    keybindConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        if input.KeyCode == Enum.KeyCode.C and getgenv().crouchGuiVisible then
            featureStates.AutoCrouch = not featureStates.AutoCrouch
            local gui = playerGui:FindFirstChild("CrouchGui")
            if gui then
                local button = gui.Frame:FindFirstChild("ToggleButton")
                if button then
                    button.Text = featureStates.AutoCrouch and "On" or "Off"
                    button.BackgroundColor3 = featureStates.AutoCrouch and Color3.fromRGB(0, 120, 80) or Color3.fromRGB(120, 0, 0)
                end
            end
        end
    end)

    Players.LocalPlayer.CharacterAdded:Connect(function(newChar)
        previousCrouchState = false
        spamDown = true
    end)
end

setupAutoCrouchListeners()

AutoCrouchToggle = Tabs.Auto:Toggle({
    Title = "Auto Crouch",
    Desc = "Press C to toggle if you on keyboard",
    Value = false,
    Callback = function(state)
        getgenv().crouchGuiVisible = state
        if state then
            if not guiInstance then
                createCrouchGui()
            else
                guiInstance.Enabled = true
            end
        else
            if guiInstance then
                guiInstance.Enabled = false
            end
        end
    end
})
AutoCrouchModeDropdown = Tabs.Auto:Dropdown({
    Title = "Auto Crouch Mode",
    Values = {"Air", "Normal", "Ground"},
    Value = "Air",
    Callback = function(value)
        featureStates.AutoCrouchMode = value
    end
})


local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")

local LocalPlayer = Players.LocalPlayer
local playerGui = LocalPlayer:WaitForChild("PlayerGui", 5)

local function makeDraggable(frame)
    local dragging = false
    local dragStart = nil
    local startPos = nil

    frame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = frame.Position
        end
    end)

    frame.InputChanged:Connect(function(input)
        if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            local delta = input.Position - dragStart
            frame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
    end)

    UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = false
        end
    end)
end

local function makeDraggable(frame)
    frame.Active = true
    frame.Draggable = true
    
    local dragDetector = Instance.new("UIDragDetector")
    dragDetector.Parent = frame
    
    local originalBackground = frame.BackgroundColor3
    local originalTransparency = frame.BackgroundTransparency
    
    frame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            frame.BackgroundTransparency = originalTransparency - 0.1
        end
    end)
    
    frame.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            frame.BackgroundTransparency = originalTransparency
        end
    end)
end

local function createAutoCarryGui(yOffset)
    local autoCarryGuiOld = playerGui:FindFirstChild("AutoCarryGui")
    if autoCarryGuiOld then
        autoCarryGuiOld:Destroy()
    end
    
    local autoCarryGui = Instance.new("ScreenGui")
    autoCarryGui.Name = "AutoCarryGui"
    autoCarryGui.IgnoreGuiInset = true
    autoCarryGui.ResetOnSpawn = false
    autoCarryGui.Enabled = getgenv().autoCarryGuiVisible
    autoCarryGui.Parent = playerGui

    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 60, 0, 60)
    frame.Position = UDim2.new(0.5, -30, 0.12 + (yOffset or 0), 0)
    frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    frame.BackgroundTransparency = 0.35
    frame.BorderSizePixel = 0
    frame.Parent = autoCarryGui
    makeDraggable(frame)

    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 6)
    corner.Parent = frame

    local stroke = Instance.new("UIStroke")
    stroke.Color = Color3.fromRGB(150, 150, 150)
    stroke.Thickness = 2
    stroke.Parent = frame

    local label = Instance.new("TextLabel")
    label.Text = "Auto"
    label.Size = UDim2.new(0.9, 0, 0.3, 0)
    label.Position = UDim2.new(0.05, 0, 0.05, 0)
    label.BackgroundTransparency = 1
    label.TextColor3 = Color3.fromRGB(255, 255, 255)
    label.Font = Enum.Font.Roboto
    label.TextSize = 14
    label.TextXAlignment = Enum.TextXAlignment.Center
    label.TextYAlignment = Enum.TextYAlignment.Center
    label.TextScaled = true
    label.Parent = frame

    local subLabel = Instance.new("TextLabel")
    subLabel.Text = "Carry"
    subLabel.Size = UDim2.new(0.9, 0, 0.3, 0)
    subLabel.Position = UDim2.new(0.05, 0, 0.3, 0)
    subLabel.BackgroundTransparency = 1
    subLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    subLabel.Font = Enum.Font.Roboto
    subLabel.TextSize = 14
    subLabel.TextXAlignment = Enum.TextXAlignment.Center
    subLabel.TextYAlignment = Enum.TextYAlignment.Center
    subLabel.TextScaled = true
    subLabel.Parent = frame

    local autoCarryGuiButton = Instance.new("TextButton")
    autoCarryGuiButton.Name = "ToggleButton"
    autoCarryGuiButton.Text = featureStates.AutoCarry and "On" or "Off"
    autoCarryGuiButton.Size = UDim2.new(0.9, 0, 0.35, 0)
    autoCarryGuiButton.Position = UDim2.new(0.05, 0, 0.6, 0)
    autoCarryGuiButton.BackgroundColor3 = featureStates.AutoCarry and Color3.fromRGB(0, 120, 80) or Color3.fromRGB(120, 0, 0)
    autoCarryGuiButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    autoCarryGuiButton.Font = Enum.Font.Roboto
    autoCarryGuiButton.TextSize = 12
    autoCarryGuiButton.TextXAlignment = Enum.TextXAlignment.Center
    autoCarryGuiButton.TextYAlignment = Enum.TextYAlignment.Center
    autoCarryGuiButton.TextScaled = true
    autoCarryGuiButton.Parent = frame

    local buttonCorner = Instance.new("UICorner")
    buttonCorner.CornerRadius = UDim.new(0, 4)
    buttonCorner.Parent = autoCarryGuiButton

    autoCarryGuiButton.MouseButton1Click:Connect(function()
        featureStates.AutoCarry = not featureStates.AutoCarry
        if featureStates.AutoCarry then
            startAutoCarry()
        else
            stopAutoCarry()
        end
        autoCarryGuiButton.Text = featureStates.AutoCarry and "On" or "Off"
        autoCarryGuiButton.BackgroundColor3 = featureStates.AutoCarry and Color3.fromRGB(0, 120, 80) or Color3.fromRGB(120, 0, 0)
    end)
end

local autoCarryInputConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Enum.KeyCode.X and getgenv().autoCarryGuiVisible then
        featureStates.AutoCarry = not featureStates.AutoCarry
        if featureStates.AutoCarry then
            startAutoCarry()
        else
            stopAutoCarry()
        end
        local autoCarryGui = playerGui:FindFirstChild("AutoCarryGui")
        if autoCarryGui and autoCarryGui.Enabled then
            local button = autoCarryGui.Frame:FindFirstChild("ToggleButton")
            if button then
                button.Text = featureStates.AutoCarry and "On" or "Off"
                button.BackgroundColor3 = featureStates.AutoCarry and Color3.fromRGB(0, 120, 80) or Color3.fromRGB(120, 0, 0)
            end
        end
        WindUI:Notify({
            Title = "Auto Carry",
            Content = "Auto Carry " .. (featureStates.AutoCarry and "enabled" or "disabled"),
            Duration = 2
        })
    end
end)

local function toggleAutoCarryGUI(state)
    getgenv().autoCarryGuiVisible = state
    local autoCarryGui = playerGui:FindFirstChild("AutoCarryGui")
    if autoCarryGui then
        autoCarryGui.Enabled = state
    end
    if state then
        WindUI:Notify({
            Title = "Auto Carry GUI",
            Content = "GUI is enabled. Press X to toggle auto carry.",
            Duration = 3
        })
    else
        WindUI:Notify({
            Title = "Auto Carry GUI",
            Content = "GUI and keybind disabled.",
            Duration = 3
        })
    end
end

AutoCarryKeybindToggle = Tabs.Auto:Toggle({
    Title = "Auto carry keybind/button",
    Desc = "Toggle gui or keybind for quick enable auto carry",
    Icon = "toggle-right",
    Value = false,
    Callback = function(state)
        toggleAutoCarryGUI(state)
    end
})

createAutoCarryGui(0)
FastReviveToggle = Tabs.Auto:Toggle({
    Title = "Fast Revive",
    Value = false,
    Callback = function(state)
        featureStates.FastRevive = state
        if state then
            startAutoRevive()
        else
            stopAutoRevive()
        end
    end
})

FastReviveMethodDropdown = Tabs.Auto:Dropdown({
    Title = "Fast Revive Method",
    Values = {"Auto", "Interact"},
    Value = "Interact",
    Callback = function(value)
        featureStates.FastReviveMethod = value
        
        stopAutoRevive()
        if featureStates.FastReviveMethod == "Interact" then
            featureStates.interactHookActive = false
        end
        
        if featureStates.FastRevive then
            startAutoRevive()
        end
    end
})

Tabs.Auto:Section({ Title = "Auto Vote", TextSize = 30 })
    AutoVoteDropdown = Tabs.Auto:Dropdown({
        Title = "loc:AUTO_VOTE_MAP",
        Values = {"Map 1", "Map 2", "Map 3", "Map 4"},
        Value = "Map 1",
        Callback = function(value)
            if value == "Map 1" then
                featureStates.SelectedMap = 1
            elseif value == "Map 2" then
                featureStates.SelectedMap = 2
            elseif value == "Map 3" then
                featureStates.SelectedMap = 3
            elseif value == "Map 4" then
                featureStates.SelectedMap = 4
            end
        end
    })

    AutoVoteToggle = Tabs.Auto:Toggle({
        Title = "loc:AUTO_VOTE",
        Value = false,
        Callback = function(state)
            featureStates.AutoVote = state
            if state then
                startAutoVote()
            else
                stopAutoVote()
            end
        end
    })
AutoVoteModeToggle = Tabs.Auto:Toggle({
    Title = "Auto Vote Game Mode",
    Value = false,
    Callback = function(state)
        if state then
            local voteConnection
            voteConnection = RunService.Heartbeat:Connect(function()
                local voteEvent = ReplicatedStorage:WaitForChild("Events"):WaitForChild("Player"):WaitForChild("Vote")
                if voteEvent then
                    if featureStates.SelectedVoteMode == 1 then
                        voteEvent:FireServer(1, true)
                    elseif featureStates.SelectedVoteMode == 2 then
                        voteEvent:FireServer(2, true)
                    elseif featureStates.SelectedVoteMode == 3 then
                        voteEvent:FireServer(3, true)
                    elseif featureStates.SelectedVoteMode == 4 then
                        voteEvent:FireServer(4, true)
                    end
                end
            end)
            
            getgenv().AutoVoteModeConnection = voteConnection
        else
            if getgenv().AutoVoteModeConnection then
                getgenv().AutoVoteModeConnection:Disconnect()
                getgenv().AutoVoteModeConnection = nil
            end
        end
    end
})

AutoVoteModeDropdown = Tabs.Auto:Dropdown({
    Title = "Vote Mode",
    Values = {"Mode 1", "Mode 2", "Mode 3", "Mode 4"},
    Value = "Mode 1",
    Callback = function(value)
        if value == "Mode 1" then
            featureStates.SelectedVoteMode = 1
        elseif value == "Mode 2" then
            featureStates.SelectedVoteMode = 2
        elseif value == "Mode 3" then
            featureStates.SelectedVoteMode = 3
        elseif value == "Mode 4" then
            featureStates.SelectedVoteMode = 4
        end
    end
})

Tabs.Auto:Section({ Title = "Auto Revive", TextSize = 30 })
featureStates.SelfReviveMethod = "Spawnpoint"
local lastSavedPosition = nil
local respawnConnection = nil
local AutoSelfReviveConnection = nil
local hasRevived = false
AutoSelfReviveToggle = Tabs.Auto:Toggle({
    Title = "loc:AUTO_SELF_REVIVE",
    Value = false,
    Callback = function(state)
        featureStates.AutoSelfRevive = state
        if state then
            if AutoSelfReviveConnection then
                AutoSelfReviveConnection:Disconnect()
            end
            if respawnConnection then
                respawnConnection:Disconnect()
            end
            local character = player.Character
            if character then
                local humanoid = character:WaitForChild("Humanoid")
                local hrp = character:WaitForChild("HumanoidRootPart")
                AutoSelfReviveConnection = character:GetAttributeChangedSignal("Downed"):Connect(function()
                    local isDowned = character:GetAttribute("Downed")
                    if isDowned then
                        if featureStates.SelfReviveMethod == "Spawnpoint" then
                            if not hasRevived then
                                hasRevived = true
                                -- [[Disabled]] task.wait(3)
                                pcall(function()
                                    ReplicatedStorage.Events.Player.ChangePlayerMode:FireServer(true)
                                end)
                                task.delay(10, function()
                                    hasRevived = false
                                end)
                            end
                        elseif featureStates.SelfReviveMethod == "Fake Revive" then
                            if hrp then
                                lastSavedPosition = hrp.Position
                            end
                            task.wait(3)
                            local startTime = tick()
                            repeat
                                pcall(function()
                              -- [[doesn't work 90%]] firesignal(game:GetService("ReplicatedStorage").Events.UI.CoverScreen.OnClientEvent, false)
                                    ReplicatedStorage:WaitForChild("Events"):WaitForChild("Player"):WaitForChild("ChangePlayerMode"):FireServer(true)
                                end)
                                task.wait(1)
                            until not character:GetAttribute("Downed") or (tick() - startTime > 1)
                            local newCharacter
                            repeat
                                newCharacter = player.Character
                                task.wait()
                            until newCharacter and newCharacter:FindFirstChild("HumanoidRootPart")
                            local newHRP = newCharacter:FindFirstChild("HumanoidRootPart")
                            if lastSavedPosition and newHRP then
                                newHRP.CFrame = CFrame.new(lastSavedPosition)
                                task.wait(0.5)
                                local movedDistance = (newHRP.Position - lastSavedPosition).Magnitude
                                if movedDistance > 1 then
                                    lastSavedPosition = nil
                                end
                            end
                        end
                    end
                end)
            end
            respawnConnection = player.CharacterAdded:Connect(function(newChar)
                task.wait(1)
                local newHumanoid = newChar:WaitForChild("Humanoid")
                local newHRP = newChar:WaitForChild("HumanoidRootPart")
                if featureStates.AutoSelfRevive then
                    AutoSelfReviveConnection = newChar:GetAttributeChangedSignal("Downed"):Connect(function()
                        local isDowned = newChar:GetAttribute("Downed")
                        if isDowned then
                            if featureStates.SelfReviveMethod == "Spawnpoint" then
                                if not hasRevived then
                                    hasRevived = true
                                    task.wait(3)
                                    pcall(function()
                                        ReplicatedStorage.Events.Player.ChangePlayerMode:FireServer(true)
                                    end)
                                    task.delay(10, function()
                                        hasRevived = false
                                    end)
                                end
                            elseif featureStates.SelfReviveMethod == "Fake Revive" then
                                if newHRP then
                                    lastSavedPosition = newHRP.Position
                                end
                                task.wait(3)
                                local startTime = tick()
                                repeat
                                    pcall(function()
                                        ReplicatedStorage:WaitForChild("Events"):WaitForChild("Player"):WaitForChild("ChangePlayerMode"):FireServer(true)
                                    end)
                                    task.wait(1)
                                until not newChar:GetAttribute("Downed") or (tick() - startTime > 1)
                                local freshCharacter
                                repeat
                                    freshCharacter = player.Character
                                    task.wait()
                                until freshCharacter and freshCharacter:FindFirstChild("HumanoidRootPart")
                                local freshHRP = freshCharacter:FindFirstChild("HumanoidRootPart")
                                if lastSavedPosition and freshHRP then
                                    freshHRP.CFrame = CFrame.new(lastSavedPosition)
                                    task.wait(0.5)
                                    local movedDistance = (freshHRP.Position - lastSavedPosition).Magnitude
                                    if movedDistance > 1 then
                                        lastSavedPosition = nil
                                    end
                                end
                            end
                        end
                    end)
                end
            end)
        else
            if AutoSelfReviveConnection then
                AutoSelfReviveConnection:Disconnect()
                AutoSelfReviveConnection = nil
            end
            if respawnConnection then
                respawnConnection:Disconnect()
                respawnConnection = nil
            end
            hasRevived = false
            lastSavedPosition = nil
        end
    end
})

SelfReviveMethodDropdown = Tabs.Auto:Dropdown({
    Title = "Self Revive Method",
    Values = {"Spawnpoint", "Fake Revive"},
    Value = "Spawnpoint",
    Callback = function(value)
        featureStates.SelfReviveMethod = value
    end
})
if player.Character and featureStates.AutoSelfRevive then
    local char = player.Character
    local humanoid = char:WaitForChild("Humanoid")
    local hrp = char:WaitForChild("HumanoidRootPart")
    AutoSelfReviveConnection = char:GetAttributeChangedSignal("Downed"):Connect(function()
    end)
end
local function manualRevive()
    local character = player.Character
    if not character then return end
    local hrp = character:FindFirstChild("HumanoidRootPart")
    local isDowned = character:GetAttribute("Downed")
    if not isDowned then return end
    
    if featureStates.SelfReviveMethod == "Spawnpoint" then
        if not hasRevived then
            hasRevived = true
            pcall(function()
                ReplicatedStorage.Events.Player.ChangePlayerMode:FireServer(true)
            end)
            task.delay(10, function()
                hasRevived = false
            end)
        end
    elseif featureStates.SelfReviveMethod == "Fake Revive" then
        if hrp then
            lastSavedPosition = hrp.Position
        end
        task.spawn(function()
            task.wait(3)
            local startTime = tick()
            repeat
                pcall(function()
                    ReplicatedStorage:WaitForChild("Events"):WaitForChild("Player"):WaitForChild("ChangePlayerMode"):FireServer(true)
                end)
                task.wait(1)
            until not character:GetAttribute("Downed") or (tick() - startTime > 1)
            
            local newCharacter
            repeat
                newCharacter = player.Character
                task.wait()
            until newCharacter and newCharacter:FindFirstChild("HumanoidRootPart")
            local newHRP = newCharacter:FindFirstChild("HumanoidRootPart")
            if lastSavedPosition and newHRP then
                newHRP.CFrame = CFrame.new(lastSavedPosition)
                task.wait(0.5)
                local movedDistance = (newHRP.Position - lastSavedPosition).Magnitude
                if movedDistance > 1 then
                    lastSavedPosition = nil
                end
            end
        end)
    end
end

Tabs.Auto:Button({
    Title = "loc:MANUAL_REVIVE",
    Desc = "Manually revive yourself",
    Icon = "heart",
    Callback = function()
        manualRevive()
    end
})

local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Event = ReplicatedStorage:FindFirstChild("Events")
local CustomServer = Event and Event:FindFirstChild("CustomServers")
local Admins = Event and Event:FindFirstChild("Admin")

local Admin = CustomServer and CustomServer:FindFirstChild("Admin")
local VIPCommand = Admins and Admins:FindFirstChild("VIPCommand")

local remoteFired = false     --  FireServer 
local mapInvoked = false      --  invoke !map 
local loopRunning = false     --  loop 

Tabs.Auto:Section({ Title = "Private Server", TextSize = 30 })

AutoWinToggle = Tabs.Auto:Toggle({
    Title = "Set Up Server (VIP Farm)",
    Value = false,
    Callback = function(state)

        featureStates.Setup = state

        if state == true then
            
            --------------------------
            --  RemoteEvent 
            --------------------------
            if not remoteFired then
                remoteFired = true

                -- 
                Admin:FireServer("Gamemode", "Pro")
                Admin:FireServer("AddMap", "DesertBus")

                task.wait(0.5)
            end

            --------------------------
            --  "!map DesertBus" 
            --------------------------
            if not mapInvoked then
                mapInvoked = true
                VIPCommand:InvokeServer("!map DesertBus")
            end

            --------------------------
            --  Loop  specialround  30 
            --------------------------
            if not loopRunning then
                loopRunning = true

                task.spawn(function()
                    while featureStates.Setup do
                        VIPCommand:InvokeServer("!specialround Plushie Hell")
                        task.wait(30)
                    end
                    loopRunning = false
                end)
            end

        else
            --  toggle =  loop
            -- states  loop 
        end
    end
})

Tabs.Auto:Section({ Title = "Auto Farm", TextSize = 30 })

    AutoWinToggle = Tabs.Auto:Toggle({
        Title = "loc:AUTO_WIN",
        Value = false,
        Callback = function(state)
            featureStates.AutoWin = state
            if state then
                startAutoWin()
            else
                stopAutoWin()
            end
        end
    })
    AutoWhistleToggle = Tabs.Auto:Toggle({
    Title = "Auto Whistle",
    Value = false,
    Callback = function(state)
        featureStates.AutoWhistle = state
        if state then
            startAutoWhistle()
        else
            stopAutoWhistle()
        end
    end
})

    AutoMoneyFarmToggle = Tabs.Auto:Toggle({
        Title = "loc:AUTO_MONEY_FARM",
        Value = false,
        Callback = function(state)
        if farmsSuppressedByAntiNextbot and state then
    WindUI:Notify({
        Title = "Farm Blocked",
        Content = "Cannot enable while Nextbot is too close. Wait or move away.",
        Duration = 3
    })
    AutoMoneyFarmToggle:Set(false)
    return
end
farmsSuppressedByAntiNextbot = false
            featureStates.AutoMoneyFarm = state
            getgenv().moneyfarm = state
            if state then
                startAutoMoneyFarm()
                featureStates.FastRevive = true
                featureStates.AutoSelfRevive = true
                featureStates.FastReviveMethod = "Auto"
                pcall(function()
                    if FastReviveMethodDropdown and FastReviveMethodDropdown.Select then
                        FastReviveMethodDropdown:Select("Auto")
                    elseif FastReviveMethodDropdown and FastReviveMethodDropdown.Set then
                        FastReviveMethodDropdown:Set("Value", "Auto")
                    end
                end)
                FastReviveToggle:Set(true)
                AutoSelfReviveToggle:Set(true)
                startAutoRevive()
            else
                stopAutoMoneyFarm()
            end
        end
    })
AutoTicketFarmToggle = Tabs.Auto:Toggle({
    Title = "Auto Ticket Farm",
    Value = false,
    Callback = function(state)
        getgenv().ticketfarm = state
        local AutoTicketFarmConnection
        local yOffset = 15
        local currentTicket = nil
        local ticketProcessedTime = 0

        if state then
            local securityPart = workspace:FindFirstChild("SecurityPart")
            if not securityPart then
                print("SecurityPart not found")
                getgenv().ticketfarm = false
                return
            end

            AutoTicketFarmConnection = game:GetService("RunService").Heartbeat:Connect(function()
                if not getgenv().ticketfarm then
                    if AutoTicketFarmConnection then
                        AutoTicketFarmConnection:Disconnect()
                        AutoTicketFarmConnection = nil
                    end
                    return
                end

                local character = player.Character
                local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
                local tickets = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Effects") and workspace.Game.Effects:FindFirstChild("Tickets")
                local playersInGame = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Players")

                if character and humanoidRootPart then
                    if character:GetAttribute("Downed") then
                        ReplicatedStorage.Events.Player.ChangePlayerMode:FireServer(true)
                        humanoidRootPart.CFrame = securityPart.CFrame + Vector3.new(0, 3, 0)
                        return
                    end

                    if getgenv().moneyfarm and playersInGame then
                        local downedPlayerFound = false
                        for _, v in pairs(playersInGame:GetChildren()) do
                            if v:IsA("Model") and v:GetAttribute("Downed") then
                                local downedRootPart = v:FindFirstChild("HumanoidRootPart")
                                if downedRootPart then
                                    humanoidRootPart.CFrame = downedRootPart.CFrame + Vector3.new(0, 3, 0)
                                    ReplicatedStorage.Events.Character.Interact:FireServer("Revive", true, v)
                                    downedPlayerFound = true
                                    currentTicket = nil 
                                    break
                                end
                            end
                        end
                        if downedPlayerFound then
                            return
                        end
                    end

                    if tickets then
                        local activeTickets = tickets:GetChildren()
                        if #activeTickets > 0 then
                            if not currentTicket or not currentTicket.Parent then
                                currentTicket = activeTickets[1]
                                ticketProcessedTime = tick()
                            end

                            if currentTicket and currentTicket.Parent then
                                local ticketPart = currentTicket:FindFirstChild("HumanoidRootPart")
                                if ticketPart then
                                    local targetPosition = ticketPart.Position + Vector3.new(0, yOffset, 0)
                                    humanoidRootPart.CFrame = CFrame.new(targetPosition)
                                    
                                    if tick() - ticketProcessedTime > 0.1 then
                                        humanoidRootPart.CFrame = ticketPart.CFrame
                                    end
                                else
                                    currentTicket = nil
                                end
                            else
                                humanoidRootPart.CFrame = securityPart.CFrame + Vector3.new(0, 3, 0)
                                currentTicket = nil
                            end
                        else
                            humanoidRootPart.CFrame = securityPart.CFrame + Vector3.new(0, 3, 0)
                            currentTicket = nil
                        end
                    else
                        humanoidRootPart.CFrame = securityPart.CFrame + Vector3.new(0, 3, 0)
                        currentTicket = nil
                    end
                end
            end)
        else
            if AutoTicketFarmConnection then
                AutoTicketFarmConnection:Disconnect()
                AutoTicketFarmConnection = nil
            end
            currentTicket = nil
            local character = player.Character or player.CharacterAdded:Wait()
            local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
            local securityPart = workspace:FindFirstChild("SecurityPart")
            if humanoidRootPart and securityPart then
                humanoidRootPart.CFrame = securityPart.CFrame + Vector3.new(0, 3, 0)
            end
        end
    end
})
-- Utility Tab
NextbotObjects = {}
NextbotObjectsToggle = false
NextbotHitboxSize = 6

function createNextbotObject(nextbot)
    if not nextbot or not nextbot.Parent then return nil end
    
    local hrp = nextbot:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end
    
    local collisionPart = Instance.new("Part")
    collisionPart.Name = "NextbotCollision"
    collisionPart.Size = Vector3.new(NextbotHitboxSize, NextbotHitboxSize + 2, NextbotHitboxSize)
    collisionPart.CFrame = hrp.CFrame
    collisionPart.Anchored = true
    collisionPart.CanCollide = true
    collisionPart.Transparency = 1
    collisionPart.Material = Enum.Material.ForceField
    collisionPart.Parent = workspace
    
    local bodyVelocity = Instance.new("BodyVelocity")
    bodyVelocity.Velocity = Vector3.new(0, 0, 0)
    bodyVelocity.MaxForce = Vector3.new(4000, 4000, 4000)
    bodyVelocity.P = 1250
    bodyVelocity.Parent = collisionPart
    
    return collisionPart
end

function updateNextbotObjects()
    for nextbot, collisionPart in pairs(NextbotObjects) do
        if not nextbot.Parent or not nextbot:FindFirstChild("HumanoidRootPart") then
            collisionPart:Destroy()
            NextbotObjects[nextbot] = nil
        end
    end
    
    local targets = {}
    
    local gameFolder = workspace:FindFirstChild("Game")
    if gameFolder and gameFolder:FindFirstChild("Players") then
        for _, model in pairs(gameFolder.Players:GetChildren()) do
            if model:IsA("Model") and isNextbotModel(model) then
                table.insert(targets, model)
            end
        end
    end
    
    if workspace:FindFirstChild("NPCs") then
        for _, model in pairs(workspace.NPCs:GetChildren()) do
            if model:IsA("Model") and isNextbotModel(model) then
                table.insert(targets, model)
            end
        end
    end
    
    for _, nextbot in ipairs(targets) do
        local hrp = nextbot:FindFirstChild("HumanoidRootPart")
        if hrp then
            if not NextbotObjects[nextbot] then
                local collisionPart = createNextbotObject(nextbot)
                if collisionPart then
                    NextbotObjects[nextbot] = collisionPart
                end
            else
                NextbotObjects[nextbot].CFrame = hrp.CFrame
                NextbotObjects[nextbot].Size = Vector3.new(NextbotHitboxSize, NextbotHitboxSize + 2, NextbotHitboxSize)
            end
        end
    end
end

function startNextbotObjects()
    if NextbotObjectsConnection then 
        NextbotObjectsConnection:Disconnect()
    end
    NextbotObjectsConnection = RunService.Heartbeat:Connect(function()
        updateNextbotObjects()
    end)
end

function stopNextbotObjects()
    if NextbotObjectsConnection then
        NextbotObjectsConnection:Disconnect()
        NextbotObjectsConnection = nil
    end
    for nextbot, collisionPart in pairs(NextbotObjects) do
        collisionPart:Destroy()
    end
    NextbotObjects = {}
end

NextbotObjectsToggle = Tabs.Utility:Toggle({
    Title = "Nextbot Collision Objects",
    Desc = "Add invisible collision (Why do you even need this shit lol",
    Value = false,
    Callback = function(state)
        NextbotObjectsToggle = state
        if state then
            startNextbotObjects()
        else
            stopNextbotObjects()
        end
    end
})

NextbotHitboxSlider = Tabs.Utility:Slider({
    Title = "Nextbot Hitbox Size",
    Desc = "Adjust the size of nextbot collision objects",
    Value = { Min = 1, Max = 200, Default = 6, Step = 1 },
    Callback = function(value)
        NextbotHitboxSize = value
        if NextbotObjectsToggle then
            for nextbot, collisionPart in pairs(NextbotObjects) do
                if collisionPart and collisionPart.Parent then
                    collisionPart.Size = Vector3.new(NextbotHitboxSize, NextbotHitboxSize + 2, NextbotHitboxSize)
                end
            end
        end
    end
})
Tabs.Utility:Toggle({
    Title = "Exchange Menu",
    Default = false,
    Callback = function(value)
        game.Players.LocalPlayer.PlayerGui.Menu.Views.Battlepass.Exchange.Visible = value
    end
})

Tabs.Utility:Toggle({
    Title = "Bypass Battle Pass Waiting",
    Desc = "Skip all battle pass requirements and unlock everything instantly",
    Callback = function(value)
        if value then
            -- Stop loop when true
            if unlockLoop then
                unlockLoop:Disconnect()
                unlockLoop = nil
            end
            game:GetService("Players").LocalPlayer.PlayerGui.Menu.Views.Battlepass.ViewPass.Center.ViewPass.Unlocked.Visible = true
        else
            -- Start loop when false
            unlockLoop = game:GetService("RunService").Heartbeat:Connect(function()
                local unlocked = game:GetService("Players").LocalPlayer.PlayerGui.Menu.Views.Battlepass.ViewPass.Center.ViewPass.Unlocked
                if unlocked and unlocked.Parent then
                    unlocked.Visible = false
                end
            end)
        end
    end
})

Tabs.Utility:Button({
    Title = "Clear Invis Walls",
    Callback = function()
        local invisPartsFolder = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Map") and workspace.Game.Map:FindFirstChild("InvisParts")
        if invisPartsFolder then
            for _, obj in ipairs(invisPartsFolder:GetDescendants()) do
                if obj:IsA("BasePart") then
                    obj.CanCollide = false
                end
            end
        end
    end
})

FreeCamToggle = Tabs.Utility:Toggle({
    Title = "Free Cam UI",
    Desc = "Note: Sometimes it's may be glitchy so don't use it too often, I can't really fix it",
    Icon = "camera",
    Value = false,
    Callback = function(state)
        controlFrame.Visible = state and isMobile
        if state and isMobile then
         print ("")
        elseif state and not isMobile then
            WindUI:Notify({
                Title = "Free Cam",
                Content = "Use Ctrl+P to toggle Free Cam.",
                Duration = 3
            })
            if not isFreecamEnabled then
                deactivateFreecam()
            end
        else
            if isFreecamEnabled then
                deactivateFreecam()
            end
        end
    end
})
local FreeCamSpeedSlider = Tabs.Utility:Slider({
    Title = "Free Cam Speed",
    Desc = "Adjust movement speed in Free Cam",
    Value = { Min = 1, Max = 500, Default = 50, Step = 1 },
    Callback = function(value)
        FREECAM_SPEED = value
    end
})

TimeChangerInput = Tabs.Utility:Input({
    Title = "Set Time (HH:MM)",
    Placeholder = "12:00",
    Callback = function(value)
        value = value:gsub("^%s*(.-)%s*$", "%1")
        
        local h_str, m_str = value:match("(%d+):(%d+)")
        if h_str and m_str then
            local h = tonumber(h_str)
            local m = tonumber(m_str)
            
            if h and m and h >= 0 and h <= 23 and m >= 0 and m <= 59 and #h_str <= 2 and #m_str <= 2 then
                local totalHours = h + (m / 60)
                game:GetService("Lighting").ClockTime = totalHours
             end
        end
    end
})

player.CharacterAdded:Connect(function()
    hasRevived = false
    if featureStates.AutoSelfRevive then
        task.wait(1)
        startAutoSelfRevive()
    end
end)
getgenv().lagSwitchEnabled = false
getgenv().lagDuration = 0.5
local lagGui = nil
local lagGuiButton = nil
local lagInputConnection = nil
local isLagActive = false
local lagSystemLoaded = false

local function makeDraggable(frame)
    frame.Active = true
    frame.Draggable = true
    
    local dragDetector = Instance.new("UIDragDetector")
    dragDetector.Parent = frame
    
    local originalBackground = frame.BackgroundColor3
    local originalTransparency = frame.BackgroundTransparency
    
    frame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            frame.BackgroundTransparency = originalTransparency - 0.1
        end
    end)
    
    frame.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            frame.BackgroundTransparency = originalTransparency
        end
    end)
end

local function loadLagSystem()
    if lagSystemLoaded then return end
    lagSystemLoaded = true
    
    if not lagInputConnection then
        lagInputConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
            if gameProcessed then return end
            if input.KeyCode == Enum.KeyCode.L and getgenv().lagSwitchEnabled and not isLagActive then
                isLagActive = true
                task.spawn(function()
                    local duration = getgenv().lagDuration or 0.5
                    local start = tick()
                    while tick() - start < duration do
                        local a = math.random(1, 1000000) * math.random(1, 1000000)
                        a = a / math.random(1, 10000)
                    end
                    isLagActive = false
                end)
            end
        end)
    end
end

local function unloadLagSystem()
    if not lagSystemLoaded then return end
    lagSystemLoaded = false
    
    if lagInputConnection then
        lagInputConnection:Disconnect()
        lagInputConnection = nil
    end
    isLagActive = false
end

local function checkLagState()
    local shouldLoad = getgenv().lagSwitchEnabled
    
    if shouldLoad and not lagSystemLoaded then
        loadLagSystem()
    elseif not shouldLoad and lagSystemLoaded then
        unloadLagSystem()
    end
end

local function createLagGui(yOffset)
    local lagGuiOld = playerGui:FindFirstChild("LagSwitchGui")
    if lagGuiOld then lagGuiOld:Destroy() end
    
    lagGui = Instance.new("ScreenGui")
    lagGui.Name = "LagSwitchGui"
    lagGui.IgnoreGuiInset = true
    lagGui.ResetOnSpawn = false
    lagGui.Enabled = getgenv().lagSwitchEnabled
    lagGui.Parent = playerGui

    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 60, 0, 60)
    frame.Position = UDim2.new(0.5, -30, 0.12 + (yOffset or 0), 0)
    frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    frame.BackgroundTransparency = 0.35
    frame.BorderSizePixel = 0
    frame.Parent = lagGui
    makeDraggable(frame)

    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 6)
    corner.Parent = frame

    local stroke = Instance.new("UIStroke")
    stroke.Color = Color3.fromRGB(150, 150, 150)
    stroke.Thickness = 2
    stroke.Parent = frame

    local label = Instance.new("TextLabel")
    label.Text = "Lag"
    label.Size = UDim2.new(0.9, 0, 0.5, 0)
    label.Position = UDim2.new(0.05, 0, 0, 0)
    label.BackgroundTransparency = 1
    label.TextColor3 = Color3.fromRGB(255, 255, 255)
    label.Font = Enum.Font.Roboto
    label.TextSize = 16
    label.TextXAlignment = Enum.TextXAlignment.Center
    label.TextYAlignment = Enum.TextYAlignment.Center
    label.TextScaled = true
    label.Parent = frame

    lagGuiButton = Instance.new("TextButton")
    lagGuiButton.Name = "TriggerButton"
    lagGuiButton.Text = "Trigger"
    lagGuiButton.Size = UDim2.new(0.9, 0, 0.5, 0)
    lagGuiButton.Position = UDim2.new(0.05, 0, 0.5, 0)
    lagGuiButton.BackgroundColor3 = Color3.fromRGB(0, 120, 80)
    lagGuiButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    lagGuiButton.Font = Enum.Font.Roboto
    lagGuiButton.TextSize = 14
    lagGuiButton.TextXAlignment = Enum.TextXAlignment.Center
    lagGuiButton.TextYAlignment = Enum.TextYAlignment.Center
    lagGuiButton.TextScaled = true
    lagGuiButton.Parent = frame

    local buttonCorner = Instance.new("UICorner")
    buttonCorner.CornerRadius = UDim.new(0, 4)
    buttonCorner.Parent = lagGuiButton

    lagGuiButton.MouseButton1Click:Connect(function()
        if not isLagActive then
            isLagActive = true
            task.spawn(function()
                local start = tick()
                while tick() - start < (getgenv().lagDuration or 0.5) do
                    local a = math.random(1, 1000000) * math.random(1, 1000000)
                    a = a / math.random(1, 10000)
                end
                isLagActive = false
            end)
        end
    end)
end

LagSwitchToggle = Tabs.Utility:Toggle({
    Title = "Lag Switch",
    Icon = "zap",
    Value = false,
    Callback = function(state)
        getgenv().lagSwitchEnabled = state
        if state then
            if not lagGui then
                createLagGui(0)
            else
                lagGui.Enabled = true
            end
        else
            if lagGui then
                lagGui.Enabled = false
            end
        end
        checkLagState()
    end
})

LagDurationInput = Tabs.Utility:Input({
    Title = "Lag Duration (seconds)",
    Placeholder = "0.5",
    Value = tostring(getgenv().lagDuration),
    NumbersOnly = true,
    Callback = function(text)
        local n = tonumber(text)
        if n and n > 0 then
            getgenv().lagDuration = n
        end
    end
})

Players.PlayerRemoving:Connect(function(leavingPlayer)
    if leavingPlayer == player then
        unloadLagSystem()
        if lagGui then
            lagGui:Destroy()
        end
    end
end)

checkLagState()
GravityToggle = Tabs.Utility:Toggle({
    Title = "Custom Gravity",
    Value = false,
    Callback = function(state)
        featureStates.CustomGravity = state
        if state then
            workspace.Gravity = featureStates.GravityValue
        else
            workspace.Gravity = originalGameGravity
        end
    end
})

GravityInput = Tabs.Utility:Input({
    Title = "Gravity Value",
    Placeholder = tostring(originalGameGravity),
    Value = tostring(featureStates.GravityValue),
    Callback = function(text)
        local num = tonumber(text)
        if num then
            featureStates.GravityValue = num
            if featureStates.CustomGravity then
                workspace.Gravity = num
            end
        end
    end
})
getgenv().gravityGuiVisible = false

GravityGUIToggle = Tabs.Utility:Toggle({
    Title = "Gravity toggle shortcuts",
    Desc = "Toggle gui or keybind for quick enable gravity",
    Icon = "toggle-right",
    Value = false,
    Callback = function(state)
        getgenv().gravityGuiVisible = state
        local gravityGui = game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("GravityGui")
        if gravityGui then
            gravityGui.Enabled = state
        end
        if not state then
            WindUI:Notify({
                Title = "Gravity GUI",
                Content = "GUI And keybind disabled.",
                Duration = 3
            })
        else
            WindUI:Notify({
                Title = "Gravity toggle shortcuts",
                Content = "GUI is enabled or Press J to toggle gravity.",
                Duration = 3
            })
        end
    end
})
featureStates.NoRender = false
featureStates.NoRenderColor = Color3.fromRGB(0, 0, 0)

NoRenderToggle = Tabs.Utility:Toggle({
    Title = "No Render",
    Desc = "Disable 3D rendering for performance",
    Value = false,
    Callback = function(state)
        featureStates.NoRender = state
        game:GetService("RunService"):Set3dRenderingEnabled(not state)
        
        if state then
            local gui = Instance.new("ScreenGui")
            gui.Name = "NoRenderBackground"
            gui.IgnoreGuiInset = true
            gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
            gui.ResetOnSpawn = false
            
            local frame = Instance.new("Frame")
            frame.Size = UDim2.new(1, 0, 1, 0)
            frame.BackgroundColor3 = featureStates.NoRenderColor
            frame.BorderSizePixel = 0
            frame.Parent = gui
            
            gui.Parent = player.PlayerGui
        else
            local gui = player.PlayerGui:FindFirstChild("NoRenderBackground")
            if gui then
                gui:Destroy()
            end
        end
    end
})

NoRenderColorPicker = Tabs.Utility:Colorpicker({
    Title = "No Render Color",
    Desc = "Choose background color when No Render is enabled",
    Default = Color3.fromRGB(0, 0, 0),
    Transparency = 0,
    Callback = function(color)
        featureStates.NoRenderColor = color
        
        if featureStates.NoRender then
            local gui = player.PlayerGui:FindFirstChild("NoRenderBackground")
            if gui then
                local frame = gui:FindFirstChildOfClass("Frame")
                if frame then
                    frame.BackgroundColor3 = color
                end
            end
        end
    end
})
featureStates.RemoveTextures = false

RemoveTexturesButton = Tabs.Utility:Button({
    Title = "Remove Textures",
    Callback = function()
        for _, part in ipairs(workspace:GetDescendants()) do
            if part:IsA("Part") or part:IsA("MeshPart") or part:IsA("UnionOperation") or part:IsA("WedgePart") or part:IsA("CornerWedgePart") then
                if part:IsA("Part") then
                    part.Material = Enum.Material.SmoothPlastic
                end
                if part:FindFirstChildWhichIsA("Texture") then
                    local texture = part:FindFirstChildWhichIsA("Texture")
                    texture.Texture = "rbxassetid://0"
                end
                if part:FindFirstChildWhichIsA("Decal") then
                    local decal = part:FindFirstChildWhichIsA("Decal")
                    decal.Texture = "rbxassetid://0"
                end
            end
        end
    end
})
game:GetService("Players").PlayerRemoving:Connect(function(leavingPlayer)
    if leavingPlayer == player then
        game:GetService("RunService"):Set3dRenderingEnabled(true)
    end
end)
LowQualityButton = Tabs.Utility:Button({
    Title = "Low Quality",
    Desc = "Disable textures, effects, and optimize graphics",
    Callback = function()
        local ToDisable = {
            Textures = true,
            VisualEffects = true,
            Parts = true,
            Particles = true,
            Sky = true
        }

        local ToEnable = {
            FullBright = false
        }

        local Stuff = {}

        for _, v in next, game:GetDescendants() do
            if ToDisable.Parts then
                if v:IsA("Part") or v:IsA("UnionOperation") or v:IsA("BasePart") then
                    v.Material = Enum.Material.SmoothPlastic
                    table.insert(Stuff, 1, v)
                end
            end
            
            if ToDisable.Particles then
                if v:IsA("ParticleEmitter") or v:IsA("Smoke") or v:IsA("Explosion") or v:IsA("Sparkles") or v:IsA("Fire") then
                    v.Enabled = false
                    table.insert(Stuff, 1, v)
                end
            end
            
            if ToDisable.VisualEffects then
                if v:IsA("BloomEffect") or v:IsA("BlurEffect") or v:IsA("DepthOfFieldEffect") or v:IsA("SunRaysEffect") then
                    v.Enabled = false
                    table.insert(Stuff, 1, v)
                end
            end
            
            if ToDisable.Textures then
                if v:IsA("Decal") or v:IsA("Texture") then
                    v.Texture = ""
                    table.insert(Stuff, 1, v)
                end
            end
            
            if ToDisable.Sky then
                if v:IsA("Sky") then
                    v.Parent = nil
                    table.insert(Stuff, 1, v)
                end
            end
        end

        if ToEnable.FullBright then
            local Lighting = game:GetService("Lighting")
            
            Lighting.FogColor = Color3.fromRGB(255, 255, 255)
            Lighting.FogEnd = math.huge
            Lighting.FogStart = math.huge
            Lighting.Ambient = Color3.fromRGB(255, 255, 255)
            Lighting.Brightness = 5
            Lighting.ColorShift_Bottom = Color3.fromRGB(255, 255, 255)
            Lighting.ColorShift_Top = Color3.fromRGB(255, 255, 255)
            Lighting.OutdoorAmbient = Color3.fromRGB(255, 255, 255)
            Lighting.Outlines = true
        end
    end
})
Tabs.Utility:Button({
    Title = "VIP CMD Macro",
    Icon = "rbxassetid://107814281854748",
    Callback = function() 
        local coreGui = game:GetService("CoreGui")
        if coreGui:FindFirstChild("MacroManagerGUI") then
            coreGui.MacroManagerGUI.Enabled = not coreGui.MacroManagerGUI.Enabled
        end
    end
})

local invisPartsFolder = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Map") and workspace.Game.Map:FindFirstChild("InvisParts")

local movingSecurityParts = false
local partSpeed = 10
local partRadius = 100
local storedSecurityParts = {}
local movementConnection = nil
local function disableInvisPartsCollision()
    if invisPartsFolder then
    WindUI:Notify({
                    Title = "Notification",
                    Content = "Invisible Border is removed",
                    Duration = 3
                })
        for _, obj in ipairs(invisPartsFolder:GetDescendants()) do
            if obj:IsA("BasePart") then
                obj.CanCollide = false
            end
        end
    end
end

local function restoreInvisPartsCollision()
    if invisPartsFolder then
    WindUI:Notify({
                    Title = "Notification",
                    Content = "Invisible Border is Restored",
                    Duration = 3
                })
        for _, obj in ipairs(invisPartsFolder:GetDescendants()) do
            if obj:IsA("BasePart") then
                obj.CanCollide = true
            end
        end
    end
end

local securityPartToggle = Tabs.Utility:Toggle({
    Title = "Moving Security Part",
    Value = false,
    Callback = function(state)
        movingSecurityParts = state
        
        if state then
            disableInvisPartsCollision()
            
            local partNames = {"SecurityPart"}
            storedSecurityParts = {}
            
            for _, partName in ipairs(partNames) do
                local part = workspace:FindFirstChild(partName)
                if part then
                    table.insert(storedSecurityParts, part)
                end
            end
            
            for _, obj in ipairs(workspace:GetDescendants()) do
                if obj:IsA("Part") and string.find(obj.Name:lower(), "securitypart") and not table.find(storedSecurityParts, obj) then
                    table.insert(storedSecurityParts, obj)
                end
            end
            
            if #storedSecurityParts == 0 then
                WindUI:Notify({
                    Title = "Security Parts",
                    Content = "No security parts found",
                    Duration = 3
                })
                movingSecurityParts = false
                restoreInvisPartsCollision()
                return
            end
            
            for _, part in ipairs(storedSecurityParts) do
                for _, child in ipairs(part:GetChildren()) do
                    if child:IsA("BodyVelocity") or child:IsA("BodyGyro") or child:IsA("BodyForce") then
                        child:Destroy()
                    end
                end
                
                part.CanCollide = true
                part.Anchored = false
                part.Massless = false
                
                local bodyVelocity = Instance.new("BodyVelocity")
                bodyVelocity.Velocity = Vector3.new(0, 0, 0)
                bodyVelocity.MaxForce = Vector3.new(4000, 4000, 4000)
                bodyVelocity.Parent = part
                
                local bodyGyro = Instance.new("BodyGyro")
                bodyGyro.MaxTorque = Vector3.new(4000, 4000, 4000)
                bodyGyro.P = 1000
                bodyGyro.D = 100
                bodyGyro.Parent = part
            end
            
            movementConnection = game:GetService("RunService").Heartbeat:Connect(function(deltaTime)
                if not movingSecurityParts or #storedSecurityParts == 0 then
                    if movementConnection then
                        movementConnection:Disconnect()
                        movementConnection = nil
                    end
                    return
                end
                
                local mainPart = storedSecurityParts[1]
                if mainPart and mainPart.Parent then
                    local time = tick()
                    local x = math.cos(time * partSpeed * 0.1) * partRadius
                    local z = math.sin(time * partSpeed * 0.1) * partRadius
                    local y = math.sin(time * partSpeed * 0.05) * 10 + 500
                    
                    mainPart.Position = Vector3.new(x - 29, y, z + 30)
                    
                    for i = 2, #storedSecurityParts do
                        local followerPart = storedSecurityParts[i]
                        if followerPart and followerPart.Parent then
                            local offsetX = (i - 1) * 5
                            local offsetZ = (i - 1) * 5
                            followerPart.Position = mainPart.Position + Vector3.new(offsetX, 0, offsetZ)
                        end
                    end
                else
                    movingSecurityParts = false
                end
            end)
        else
            restoreInvisPartsCollision()
            
            if movementConnection then
                movementConnection:Disconnect()
                movementConnection = nil
            end
            
            for _, part in ipairs(storedSecurityParts) do
                if part and part.Parent then
                    part.Anchored = true
                    part.Position = Vector3.new(0, 500, 0)
                    
                    for _, child in ipairs(part:GetChildren()) do
                        if child:IsA("BodyVelocity") or child:IsA("BodyGyro") or child:IsA("BodyForce") then
                            child:Destroy()
                        end
                    end
                end
            end
            storedSecurityParts = {}
        end
    end
})

local partSpeedInput = Tabs.Utility:Input({
    Title = "Part Speed",
    Placeholder = "10",
    Value = tostring(partSpeed),
    NumbersOnly = true,
    Callback = function(value)
        local speed = tonumber(value)
        if speed and speed > 0 then
            partSpeed = speed
        end
    end
})

local partRadiusInput = Tabs.Utility:Input({
    Title = "Part Radius",
    Placeholder = "100",
    Value = tostring(partRadius),
    NumbersOnly = true,
    Callback = function(value)
        local radius = tonumber(value)
        if radius and radius > 0 then
            partRadius = radius
        end
    end
})

local speedPadConnection = nil
local speedPadCharAddedConn = nil

if not featureStates.SpeedPadValue then
    featureStates.SpeedPadValue = 1.3
end
if not featureStates.SpeedPadDuration then
    featureStates.SpeedPadDuration = 2
end


SpeedPadToggle = Tabs.Utility:Toggle({
    Title = "SpeedPad Booster",
    Value = false,
    Callback = function(state)
        featureStates.SpeedPad = state
        if state then
            local character = player.Character or player.CharacterAdded:Wait()
            local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
            local SPEED_PAD = workspace.Game.Effects.Deployables:WaitForChild("SpeedPad")
            local SPEED_PAD_POSITION = SPEED_PAD.PrimaryPart and SPEED_PAD.PrimaryPart.Position or SPEED_PAD:GetPivot().Position
            local MIN_DISTANCE = 1
            local MAX_DISTANCE = 9
            local alreadyBoosted = false

            local function applySpeedBoost()
                if alreadyBoosted then return end
                alreadyBoosted = true
                pcall(function()
                    firesignal(ReplicatedStorage.Events.Character.SpeedBoost.OnClientEvent, "SpeedPad", featureStates.SpeedPadValue, featureStates.SpeedPadDuration, Color3.new(0.490196, 0.607843, 1.000000))
                end)
                task.wait(1)
                alreadyBoosted = false
            end

            speedPadConnection = RunService.Heartbeat:Connect(function()
                if not humanoidRootPart or not humanoidRootPart.Parent then
                    character = player.Character or player.CharacterAdded:Wait()
                    humanoidRootPart = character:WaitForChild("HumanoidRootPart")
                    return
                end
                local distance = (humanoidRootPart.Position - SPEED_PAD_POSITION).Magnitude
                if distance >= MIN_DISTANCE and distance <= MAX_DISTANCE then
                    applySpeedBoost()
                end
            end)

            if speedPadCharAddedConn then
                speedPadCharAddedConn:Disconnect()
            end
            speedPadCharAddedConn = player.CharacterAdded:Connect(function(newChar)
                character = newChar
                humanoidRootPart = character:WaitForChild("HumanoidRootPart")
                alreadyBoosted = false
            end)
        else
            if speedPadConnection then
                speedPadConnection:Disconnect()
                speedPadConnection = nil
            end
            if speedPadCharAddedConn then
                speedPadCharAddedConn:Disconnect()
                speedPadCharAddedConn = nil
            end
        end
    end
})

SpeedPadValueInput = Tabs.Utility:Input({
    Title = "Speed Value",
    Placeholder = "1.3",
    Value = tostring(featureStates.SpeedPadValue),
    NumbersOnly = true,
    Callback = function(text)
        local num = tonumber(text)
        if num then
            featureStates.SpeedPadValue = num
        end
    end
})

SpeedPadDurationInput = Tabs.Utility:Input({
    Title = "Duration",
    Placeholder = "2",
    Value = tostring(featureStates.SpeedPadDuration),
    NumbersOnly = true,
    Callback = function(text)
        local num = tonumber(text)
        if num then
            featureStates.SpeedPadDuration = num
        end
    end
})
local jumpPadConnection = nil
local jumpPadCharAddedConn = nil

if not featureStates.JumpPadBooster then
    featureStates.JumpPadBooster = false
end
if not featureStates.JumpPadValue then
    featureStates.JumpPadValue = 0
end

local function setupJumpPadBooster(character)
    if jumpPadConnection then
        jumpPadConnection:Disconnect()
        jumpPadConnection = nil
    end
    
    local humanoid = character:WaitForChild("Humanoid")
    local rootPart = character:WaitForChild("HumanoidRootPart")
    local jumpPad = workspace.Game.Effects.Deployables:WaitForChild("JumpPad")
    local deployableEvent = ReplicatedStorage.Events.Other.DeployableUsed.OnClientEvent

    local function onDeployableUsed(deployable, usedOnPlayerModel)
        if deployable ~= jumpPad then return end

        if not usedOnPlayerModel or not usedOnPlayerModel.Parent then return end
        if usedOnPlayerModel.Name ~= player.Name then return end
        if usedOnPlayerModel.Parent ~= workspace.Game.Players then return end

        rootPart.Velocity = Vector3.new(0, featureStates.JumpPadValue, 0)
        humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
    end

    jumpPadConnection = deployableEvent:Connect(onDeployableUsed)
end

JumpPadToggle = Tabs.Utility:Toggle({
    Title = "Jump Pad Booster",
    Value = false,
    Callback = function(state)
        featureStates.JumpPadBooster = state
        if state then
            local character = player.Character or player.CharacterAdded:Wait()
            setupJumpPadBooster(character)

            if jumpPadCharAddedConn then
                jumpPadCharAddedConn:Disconnect()
            end
            jumpPadCharAddedConn = player.CharacterAdded:Connect(function(newChar)
                task.wait(1)
                setupJumpPadBooster(newChar)
            end)

            if humanoid.FloorMaterial == Enum.Material.Air then
                local tempPart = Instance.new("Part")
                tempPart.Name = "TempBouncePart"
                tempPart.Size = Vector3.new(10, 1, 10)
                tempPart.Position = rootPart.Position - Vector3.new(0, 3, 0)
                tempPart.Anchored = true
                tempPart.CanCollide = true
                tempPart.Transparency = 1
                tempPart.Parent = workspace

                rootPart.Velocity = Vector3.new(0, featureStates.JumpPadValue, 0)
                humanoid:ChangeState(Enum.HumanoidStateType.Jumping)

                game:GetService("Debris"):AddItem(tempPart, 1)
            end
        else
            if jumpPadConnection then
                jumpPadConnection:Disconnect()
                jumpPadConnection = nil
            end
            if jumpPadCharAddedConn then
                jumpPadCharAddedConn:Disconnect()
                jumpPadCharAddedConn = nil
            end
        end
    end
})

JumpPadValueInput = Tabs.Utility:Input({
    Title = "Jump Value",
    Placeholder = "0",
    Value = tostring(featureStates.JumpPadValue),
    NumbersOnly = true,
    Callback = function(text)
        local num = tonumber(text)
        if num then
            featureStates.JumpPadValue = num
        end
    end
})
local UnlimitedColaToggle = Tabs.Utility:Toggle({
    Title = "Unlimited Cola",
    Desc = "Block The ''ToolAction:FireServer'' remote when the value is ''(0, 19)'' This feature is a visual So no one can see you drink, Have fun of trick your viewer",
    Value = false,
    Callback = function(state)
        featureStates.UnlimitedCola = state
        
        if state then
            local ReplicatedStorage = game:GetService("ReplicatedStorage")
            local RemoteEvent = ReplicatedStorage.Events.Character.ToolAction

            local mt = getrawmetatable(RemoteEvent)
            local oldNamecall = mt.__namecall

            local recentBlockTime = 0
            local blockCooldown = 0.1

            setreadonly(mt, false)

            mt.__namecall = newcclosure(function(self, ...)
                local method = getnamecallmethod()
                local args = {...}
                
                if method == "FireServer" and args[2] == 19 then
                    local currentTime = tick()
                    
                    if currentTime - recentBlockTime >= blockCooldown then
                        print("Blocked FireServer call with value 19")
                        recentBlockTime = currentTime
                        return nil
                    else
                        print("Value 19 detected but allowing call (cooldown active)")
                    end
                end
                
                return oldNamecall(self, ...)
            end)

            setreadonly(mt, true)

            featureStates.ColaMetatableHook = {
                mt = mt,
                oldNamecall = oldNamecall
            }

            local Players = game:GetService("Players")
            local player = Players.LocalPlayer
            local events = player.PlayerScripts.Events.temporary_events

            featureStates.ColaEventConnection = events.UseKeybind.Event:Connect(function(args)
                if args.Forced and args.Key == "Cola" and args.Down then
                    wait(2.15)
                    firesignal(game:GetService("ReplicatedStorage").Events.Character.SpeedBoost.OnClientEvent, "Cola", 1.4, 3.5, Color3.fromRGB(199, 141, 93))
                end
            end)

        else
            if featureStates.ColaMetatableHook then
                local mt = featureStates.ColaMetatableHook.mt
                local oldNamecall = featureStates.ColaMetatableHook.oldNamecall
                
                setreadonly(mt, false)
                mt.__namecall = oldNamecall
                setreadonly(mt, true)
                
                featureStates.ColaMetatableHook = nil
            end
            
            if featureStates.ColaEventConnection then
                featureStates.ColaEventConnection:Disconnect()
                featureStates.ColaEventConnection = nil
            end
        end
    end
})
local ColaSpeedBoosterToggle = Tabs.Utility:Toggle({
    Title = "Cola Speed Booster",
    Value = false,
    Callback = function(state)
        featureStates.ColaSpeedBooster = state
        
        if state then
            local Players = game:GetService("Players")
            local player = Players.LocalPlayer
            local events = player.PlayerScripts.Events.temporary_events

            featureStates.ColaSpeedEventConnection = events.UseKeybind.Event:Connect(function(args)
                if args.Forced and args.Key == "Cola" and args.Down then
                    wait(2.14)
                    
                    local speed = featureStates.ColaSpeedValue or 1.4
                    local duration = featureStates.ColaDurationValue or 3.5
                    
                    firesignal(game:GetService("ReplicatedStorage").Events.Character.SpeedBoost.OnClientEvent, "Cola", speed, duration, Color3.fromRGB(199, 141, 93))
                end
            end)

        else
            if featureStates.ColaSpeedEventConnection then
                featureStates.ColaSpeedEventConnection:Disconnect()
                featureStates.ColaSpeedEventConnection = nil
            end
        end
    end
})

local ColaSpeedInput = Tabs.Utility:Input({
    Title = "Speed Value",
    Placeholder = "1.4",
    NumbersOnly = true,
    Callback = function(value)
        local num = tonumber(value)
        if num and num > 0 then
            featureStates.ColaSpeedValue = num
        end
    end
})

local ColaDurationInput = Tabs.Utility:Input({
    Title = "Duration",
    Placeholder = "3.5",
    NumbersOnly = true,
    Callback = function(value)
        local num = tonumber(value)
        if num and num > 0 then
            featureStates.ColaDurationValue = num
        end
    end
})
-- teleports tab
Tabs.Teleport:Section({ Title = "Teleports", TextSize = 20 })
Tabs.Teleport:Divider()

Tabs.Teleport:Button({
    Title = "Teleport to Spawn",
    Desc = "Teleport to a random spawn location",
    Icon = "home",
    Callback = function()
        local spawnsFolder = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Map") and workspace.Game.Map:FindFirstChild("Parts") and workspace.Game.Map.Parts:FindFirstChild("Spawns")
        
        if spawnsFolder then
            local spawnLocations = spawnsFolder:GetChildren()
            if #spawnLocations > 0 then
                local randomSpawn = spawnLocations[math.random(1, #spawnLocations)]
                local character = player.Character
                local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
                
                if humanoidRootPart then
                    humanoidRootPart.CFrame = randomSpawn.CFrame + Vector3.new(0, 3, 0)
                end
            end
        end
    end
})

Tabs.Teleport:Button({
    Title = "Teleport to Random Player",
    Desc = "Teleport to a random online player",
    Icon = "users",
    Callback = function()
        local players = Players:GetPlayers()
        local validPlayers = {}
        
        for _, plr in ipairs(players) do
            if plr ~= player and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                table.insert(validPlayers, plr)
            end
        end
        
        if #validPlayers > 0 then
            local randomPlayer = validPlayers[math.random(1, #validPlayers)]
            local character = player.Character
            local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
            
            if humanoidRootPart then
                humanoidRootPart.CFrame = randomPlayer.Character.HumanoidRootPart.CFrame + Vector3.new(0, 3, 0)
            end
        end
    end
})

Tabs.Teleport:Button({
    Title = "Teleport to Downed Player",
    Desc = "Teleport to a random downed player",
    Icon = "heart",
    Callback = function()
        local playersFolder = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Players")
        local downedPlayers = {}
        
        if playersFolder then
            for _, model in ipairs(playersFolder:GetChildren()) do
                if model:IsA("Model") and model:GetAttribute("Downed") == true and model.Name ~= player.Name then
                    local hrp = model:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        table.insert(downedPlayers, model)
                    end
                end
            end
        end
        
        if #downedPlayers > 0 then
            local randomDowned = downedPlayers[math.random(1, #downedPlayers)]
            local character = player.Character
            local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
            
            if humanoidRootPart then
                humanoidRootPart.CFrame = randomDowned.HumanoidRootPart.CFrame + Vector3.new(0, 3, 0)
            end
        end
    end
})

local playerList = {}
PlayerDropdown = Tabs.Teleport:Dropdown({
    Title = "Select Player",
    Values = {"No players found"},
    Value = "No players found",
    Callback = function(selectedPlayer)
    end
})

local function updatePlayerList()
    playerList = {}
    local players = Players:GetPlayers()
    local playerNames = {}
    
    for _, plr in ipairs(players) do
        if plr ~= player then
            table.insert(playerList, plr)
            table.insert(playerNames, plr.Name)
        end
    end
    
    if #playerNames == 0 then
        playerNames = {"No players found"}
    end
    
    PlayerDropdown:Refresh(playerNames, true)
end

updatePlayerList()
Players.PlayerAdded:Connect(updatePlayerList)
Players.PlayerRemoving:Connect(updatePlayerList)

Tabs.Teleport:Button({
    Title = "Teleport to Selected Player",
    Desc = "Teleport to the player selected in dropdown",
    Icon = "user",
    Callback = function()
        local selectedPlayerName = PlayerDropdown.Value
        if selectedPlayerName ~= "No players found" then
            for _, plr in ipairs(playerList) do
                if plr.Name == selectedPlayerName and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                    local character = player.Character
                    local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
                    
                    if humanoidRootPart then
                        humanoidRootPart.CFrame = plr.Character.HumanoidRootPart.CFrame + Vector3.new(0, 3, 0)
                    end
                    break
                end
            end
        end
    end
})

Tabs.Teleport:Button({
    Title = "Teleport to Ticket",
    Desc = "Teleport to a random ticket",
    Icon = "ticket",
    Callback = function()
        local tickets = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Effects") and workspace.Game.Effects:FindFirstChild("Tickets")
        
        if tickets then
            local ticketList = tickets:GetChildren()
            if #ticketList > 0 then
                local randomTicket = ticketList[math.random(1, #ticketList)]
                local ticketPart = randomTicket:FindFirstChild("HumanoidRootPart")
                
                if ticketPart then
                    local character = player.Character
                    local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
                    
                    if humanoidRootPart then
                        humanoidRootPart.CFrame = ticketPart.CFrame + Vector3.new(0, 3, 0)
                    end
                end
            end
        end
    end
})

Tabs.Teleport:Button({
    Title = "Teleport to Nextbot",
    Desc = "Teleport to a random nextbot",
    Icon = "ghost",
    Callback = function()
        local nextbots = {}
        
        local playersFolder = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Players")
        if playersFolder then
            for _, model in ipairs(playersFolder:GetChildren()) do
                if model:IsA("Model") and isNextbotModel(model) then
                    local hrp = model:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        table.insert(nextbots, model)
                    end
                end
            end
        end
        
        local npcsFolder = workspace:FindFirstChild("NPCs")
        if npcsFolder then
            for _, model in ipairs(npcsFolder:GetChildren()) do
                if model:IsA("Model") and isNextbotModel(model) then
                    local hrp = model:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        table.insert(nextbots, model)
                    end
                end
            end
        end
        
        if #nextbots > 0 then
            local randomNextbot = nextbots[math.random(1, #nextbots)]
            local character = player.Character
            local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
            
            if humanoidRootPart then
                humanoidRootPart.CFrame = randomNextbot.HumanoidRootPart.CFrame + Vector3.new(0, 10, 0)
            end
        end
    end
})

Tabs.Teleport:Button({
    Title = "Teleport to SecurityPart",
    Icon = "shield",
    Callback = function()
        local existingPart = workspace:FindFirstChild("SecurityPart")
        
        if existingPart then
            local character = game.Players.LocalPlayer.Character
            
            if character then
                local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                
                if humanoidRootPart then
                    humanoidRootPart.CFrame = existingPart.CFrame + Vector3.new(0, 3, 0)
                end
            end
        else
            print("SecurityPart not found")
        end
    end
})

    -- Settings Tab
    Tabs.Settings:Section({ Title = "Settings", TextSize = 40 })
    Tabs.Settings:Section({ Title = "Personalize", TextSize = 20 })
    Tabs.Settings:Divider()

    local themes = {}
    for themeName, _ in pairs(WindUI:GetThemes()) do
        table.insert(themes, themeName)
    end
    table.sort(themes)

    local canChangeTheme = true
    local canChangeDropdown = true

    ThemeDropdown = Tabs.Settings:Dropdown({
        Title = "loc:THEME_SELECT",
        Values = themes,
        SearchBarEnabled = true,
        MenuWidth = 280,
        Value = "Dark",
        Callback = function(theme)
            if canChangeDropdown then
                canChangeTheme = false
                WindUI:SetTheme(theme)
                canChangeTheme = true
            end
        end
    })

    local TransparencySlider = Tabs.Settings:Slider({
        Title = "loc:TRANSPARENCY",
        Value = { Min = 0, Max = 1, Default = 0.2, Step = 0.1 },
        Callback = function(value)
            WindUI.TransparencyValue = tonumber(value)
            Window:ToggleTransparency(tonumber(value) > 0)
        end
    })

    ThemeToggle = Tabs.Settings:Toggle({
        Title = "Enable Dark Mode",
        Desc = "Use dark color scheme",
        Value = true,
        Callback = function(state)
            if canChangeTheme then
                local newTheme = state and "Dark" or "Light"
                WindUI:SetTheme(newTheme)
                if canChangeDropdown then
                    ThemeDropdown:Select(newTheme)
                end
            end
        end
    })

    WindUI:OnThemeChange(function(theme)
        canChangeTheme = false
        ThemeToggle:Set(theme == "Dark")
        canChangeTheme = true
    end)

    -- Configuration Manager
    local configName = "default"
    local configFile = nil
    local MyPlayerData = {
        name = player.Name,
        level = 1,
        inventory = {}
    }

    Tabs.Settings:Section({ Title = "Configuration Manager", TextSize = 20 })
    Tabs.Settings:Section({ Title = "Save and load your settings", TextSize = 16, TextTransparency = 0.25 })
    Tabs.Settings:Divider()

    Tabs.Settings:Input({
        Title = "Config Name",
        Value = configName,
        Callback = function(value)
            configName = value or "default"
        end
    })

    local ConfigManager = Window.ConfigManager
    if ConfigManager then
        ConfigManager:Init(Window)
        
        Tabs.Settings:Button({
            Title = "loc:SAVE_CONFIG",
            Icon = "save",
            Variant = "Primary",
            Callback = function()
                configFile = ConfigManager:CreateConfig(configName)
                    configFile:Register("AntiNextbotToggle", AntiNextbotToggle)
    configFile:Register("AntiNextbotTeleportTypeDropdown", AntiNextbotTeleportTypeDropdown)
    configFile:Register("AntiNextbotDistanceInput", AntiNextbotDistanceInput)
    configFile:Register("DistanceTeleportInput", DistanceTeleportInput)
    
                configFile:Register("InfiniteJumpToggle", InfiniteJumpToggle)
                configFile:Register("AutoTicketFarmToggle", AutoTicketFarmToggle)
                configFile:Register("TicketEspToggle", TicketEspToggle)
                configFile:Register("TicketBoxEspToggle", TicketBoxEspToggle)
                configFile:Register("EspTypeDropdown", EspTypeDropdown)
                configFile:Register("TicketTracerEspToggle", TicketTracerEspToggle)
                configFile:Register("TicketDistanceEspToggle", TicketDistanceEspToggle)
                configFile:Register("HighlightsTicketEspToggle", HighlightsTicketEspToggle)
                configFile:Register("FreeCamSpeedSlider", FreeCamSpeedSlider)
                configFile:Register("JumpMethodDropdown", JumpMethodDropdown)
                configFile:Register("FlyToggle", FlyToggle)
                configFile:Register("FlySpeedSlider", FlySpeedSlider)
                configFile:Register("ZoomSlider", ZoomSlider)
                configFile:Register("TPWALKToggle", TPWALKToggle)
                configFile:Register("TPWALKSlider", TPWALKSlider)
                configFile:Register("JumpBoostToggle", JumpBoostToggle)
                configFile:Register("JumpBoostSlider", JumpBoostSlider)
                configFile:Register("AntiAFKToggle", AntiAFKToggle)
                configFile:Register("FullBrightToggle", FullBrightToggle)
                configFile:Register("PlayerBoxESPToggle", PlayerBoxESPToggle)
                configFile:Register("PlayerBoxTypeDropdown", PlayerBoxTypeDropdown)
                configFile:Register("PlayerTracerToggle", PlayerTracerToggle)
                configFile:Register("PlayerNameESPToggle", PlayerNameESPToggle)
                configFile:Register("PlayerDistanceESPToggle", PlayerDistanceESPToggle)
                configFile:Register("PlayerRainbowBoxesToggle", PlayerRainbowBoxesToggle)
                configFile:Register("PlayerRainbowTracersToggle", PlayerRainbowTracersToggle)
                configFile:Register("NextbotESPToggle", NextbotESPToggle)
                configFile:Register("NextbotBoxESPToggle", NextbotBoxESPToggle)
                configFile:Register("NextbotBoxTypeDropdown", NextbotBoxTypeDropdown)
                configFile:Register("NextbotTracerToggle", NextbotTracerToggle)
                configFile:Register("NextbotDistanceESPToggle", NextbotDistanceESPToggle)
                configFile:Register("NextbotRainbowBoxesToggle", NextbotRainbowBoxesToggle)
                configFile:Register("NextbotRainbowTracersToggle", NextbotRainbowTracersToggle)
                configFile:Register("DownedBoxESPToggle", DownedBoxESPToggle)
                configFile:Register("DownedBoxTypeDropdown", DownedBoxTypeDropdown)
 configFile:Register("NoFogToggle", NoFogToggle)
                configFile:Register("DownedTracerToggle", DownedTracerToggle)
                configFile:Register("DownedNameESPToggle", DownedNameESPToggle)
                configFile:Register("DownedDistanceESPToggle", DownedDistanceESPToggle)
                configFile:Register("AutoCarryToggle", AutoCarryToggle)
                configFile:Register("AutoReviveToggle", FastReviveToggle)
                configFile:Register("FastReviveToggle", FastReviveToggle)
                configFile:Register("AutoVoteDropdown", AutoVoteDropdown)
                configFile:Register("AutoVoteToggle", AutoVoteToggle)
                configFile:Register("AutoSelfReviveToggle", AutoSelfReviveToggle)
                configFile:Register("AutoWinToggle", AutoWinToggle)
                configFile:Register("TimerDisplayToggle", TimerDisplayToggle)
                configFile:Register("AutoMoneyFarmToggle", AutoMoneyFarmToggle)
                configFile:Register("ThemeDropdown", ThemeDropdown)
                configFile:Register("TransparencySlider", TransparencySlider)
                configFile:Register("ThemeToggle", ThemeToggle)
                configFile:Register("SpeedInput", SpeedInput)
                configFile:Register("AutoWhistleToggle", AutoWhistleToggle)
                configFile:Register("JumpCapInput", JumpCapInput)
                configFile:Register("StrafeInput", StrafeInput)
                configFile:Register("ApplyMethodDropdown", ApplyMethodDropdown)
                configFile:Register("InfiniteSlideToggle", InfiniteSlideToggle)
                configFile:Register("GravityToggle", GravityToggle)
                configFile:Register("GravityInput", GravityInput)
                configFile:Register("InfiniteSlideSpeedInput", InfiniteSlideSpeedInput)
                configFile:Register("LagSwitchToggle", LagSwitchToggle)
                configFile:Register("LagDurationInput", LagDurationInput)
                configFile:Set("playerData", MyPlayerData)
                configFile:Set("lastSave", os.date("%Y-%m-%d %H:%M:%S"))
                configFile:Save()
            end
        })

        Tabs.Settings:Button({
            Title = "loc:LOAD_CONFIG",
            Icon = "folder",
            Callback = function()
                configFile = ConfigManager:CreateConfig(configName)
                local loadedData = configFile:Load()
                if loadedData then
                    if loadedData.playerData then
                        MyPlayerData = loadedData.playerData
                    end
                    local lastSave = loadedData.lastSave or "Unknown"
                    Tabs.Settings:Paragraph({
                        Title = "Player Data",
                        Desc = string.format("Name: %s\nLevel: %d\nInventory: %s", 
                            MyPlayerData.name, 
                            MyPlayerData.level, 
                            table.concat(MyPlayerData.inventory, ", "))
                    })
                end
            end
        })
    else
        Tabs.Settings:Paragraph({
            Title = "Config Manager Not Available",
            Desc = "This feature requires ConfigManager",
            Image = "alert-triangle",
            ImageSize = 20,
            Color = "White"
        })
    end
        Tabs.Settings:Keybind({
        Flag = "Keybind",
        Title = "Keybind",
        Desc = "Keybind to open ui",
        Value = "RightControl",
        Callback = function(RightControl)
            Window:SetToggleKey(Enum.KeyCode[RightControl])
        end
    })

Tabs.Settings:Section({ Title = "Game Settings (In Beta)", TextSize = 35 })
Tabs.Settings:Section({ Title = "Note: This is a permanent Changes, it's can be used to pass limit value", TextSize = 15 })
Tabs.Settings:Divider()
Tabs.Settings:Section({ Title = "Visual", TextSize = 20 })
local Lighting = game:GetService("Lighting")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ChangeSettingRemote = ReplicatedStorage:WaitForChild("Events"):WaitForChild("Data"):WaitForChild("ChangeSetting")
local UpdatedEvent = game:GetService("ReplicatedStorage").Modules.Client.Settings.Updated

local UpdatedEvent = game:GetService("ReplicatedStorage").Modules.Client.Settings.Updated
local ChangeSettingRemote = game:GetService("ReplicatedStorage").Events.Data.ChangeSetting

MapShadowToggle = Tabs.Settings:Toggle({
    Title = "Map Shadow",
    Callback = function(state)
        ChangeSettingRemote:InvokeServer(6, state)
        UpdatedEvent:Fire(6, state)
    end
})

LowGraphicToggle = Tabs.Settings:Toggle({
    Title = "Low graphic",
    Callback = function(state)
        ChangeSettingRemote:InvokeServer(5, state)
        UpdatedEvent:Fire(5, state)
    end
})
RagdollToggle = Tabs.Settings:Toggle({
    Title = "Ragdoll",
    Callback = function(state)
        ChangeSettingRemote:InvokeServer(10, state)
        UpdatedEvent:Fire(10, state)
    end
})
MusicVolumeInput = Tabs.Settings:Input({
    Title = "Music volume",
    Placeholder = "0.5",
    NumbersOnly = true,
    Callback = function(value)
        local num = tonumber(value)
        if num then
            ChangeSettingRemote:InvokeServer(7, num)
            UpdatedEvent:Fire(7, num)
        end
    end
})
NextbotVolumeInput = Tabs.Settings:Input({
    Title = "Nextbot volume",
    Placeholder = "100",
    NumbersOnly = true,
    Callback = function(value)
        local num = tonumber(value)
        if num then
            ChangeSettingRemote:InvokeServer(9, num)
            UpdatedEvent:Fire(9, num)
        end
    end
})

BoomBoxVolumeInput = Tabs.Settings:Input({
    Title = "Boom box volume",
    Placeholder = "100",
    NumbersOnly = true,
    Callback = function(value)
        local num = tonumber(value)
        if num then
            ChangeSettingRemote:InvokeServer(4, num)
            UpdatedEvent:Fire(4, num)
        end
    end
})

EmoteVolumeInput = Tabs.Settings:Input({
    Title = "Emote volume",
    Placeholder = "100",
    NumbersOnly = true,
    Callback = function(value)
        local num = tonumber(value)
        if num then
            ChangeSettingRemote:InvokeServer(8, num)
            UpdatedEvent:Fire(8, num)
        end
    end
})

NextbotVignetteToggle = Tabs.Settings:Toggle({
    Title = "Nextbot vignette",
    Callback = function(state)
        ChangeSettingRemote:InvokeServer(12, state)
        UpdatedEvent:Fire(12, state)
    end
})

R15EnabledToggle = Tabs.Settings:Toggle({
    Title = "R15 enabled",
    Callback = function(state)
        ChangeSettingRemote:InvokeServer(15, state)
        UpdatedEvent:Fire(15, state)
    end
})

AnimatedTagToggle = Tabs.Settings:Toggle({
    Title = "Animated tag",
    Callback = function(state)
        ChangeSettingRemote:InvokeServer(18, state)
        UpdatedEvent:Fire(18, state)
    end
})
Tabs.Settings:Section({ Title = "Game", TextSize = 20 })
CanBeCarriedToggle = Tabs.Settings:Toggle({
    Title = "Can be carried",
    Callback = function(state)
        ChangeSettingRemote:InvokeServer(1, state)
        UpdatedEvent:Fire(1, state)
    end
})

FovInput = Tabs.Settings:Input({
    Title = "Fov",
    Placeholder = "100",
    NumbersOnly = true,
    Callback = function(value)
        local num = tonumber(value)
        if num then
            ChangeSettingRemote:InvokeServer(2, num)
            UpdatedEvent:Fire(2, num)
        end
    end
})

PovScrollToggle = Tabs.Settings:Toggle({
    Title = "Pov scroll",
    Callback = function(state)
        ChangeSettingRemote:InvokeServer(13, state)
        UpdatedEvent:Fire(13, state)
    end
})

SprintViewmodelToggle = Tabs.Settings:Toggle({
    Title = "Sprint viewmodel",
    Callback = function(state)
        ChangeSettingRemote:InvokeServer(11, state)
        UpdatedEvent:Fire(11, state)
    end
})

ViewbobToggle = Tabs.Settings:Toggle({
    Title = "Viewbob",
    Callback = function(state)
        ChangeSettingRemote:InvokeServer(3, state)
        UpdatedEvent:Fire(3, state)
    end
})

VoicchatVolumeInput = Tabs.Settings:Input({
    Title = "Voicchat volume",
    Placeholder = "100",
    NumbersOnly = true,
    Callback = function(value)
        local num = tonumber(value)
        if num then
            ChangeSettingRemote:InvokeServer(14, num)
            UpdatedEvent:Fire(14, num)
        end
    end
})

    Window:SelectTab(1)
end



setupGui()
setupMobileJumpButton()

Window:OnClose(function()
    isWindowOpen = false
	print ("Press " .. getCleanKeyName(currentKey) .. " To Reopen")
    if ConfigManager and configFile then
        configFile:Set("playerData", MyPlayerData)
        configFile:Set("lastSave", os.date("%Y-%m-%d %H:%M:%S"))
        configFile:Save()
    end
    if not game:GetService("UserInputService").TouchEnabled then
        pcall(function()
            WindUI:Notify({
                Title = "GUI Closed",
                Content = "Press " .. getCleanKeyName(currentKey) .. " To Reopen",
                Duration = 3
            })
        end)
    end
end)
Window:OnDestroy(function()
    print("Window destroyed")
    if keyConnection then
        keyConnection:Disconnect()
    end
    if keyInputConnection then
        keyInputConnection:Disconnect()
    end
    saveKeybind()
end)

Window:OnOpen(function()
    print("Window opened")
    isWindowOpen = true
end)

Window:UnlockAll()



task.spawn(function()
    while true do
        task.wait(0.5)
        local currentlyPresent = isPlayerModelPresent()
        
        if currentlyPresent and not playerModelPresent then
            playerModelPresent = true
            applyStoredSettings()
        elseif not currentlyPresent and playerModelPresent then
            playerModelPresent = false
        end
    end
end)

game:GetService("UserInputService").WindowFocused:Connect(function()
    saveKeybind()
end)


do
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer
local playerGui = LocalPlayer:WaitForChild("PlayerGui")

local uiToggledViaUI = false 
local isMobile = UserInputService.TouchEnabled 
local function makeDraggable(frame)
    local dragging, dragInput, dragStart, startPos
    frame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            dragStart = input.Position
            startPos = frame.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then dragging = false end
            end)
        end
    end)
    frame.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseMovement then
            dragInput = input
        end
    end)
    UserInputService.InputChanged:Connect(function(input)
        if dragging and input == dragInput then
            local delta = input.Position - dragStart
            frame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
    end)
end
local function createToggleGui(name, varName, yOffset)
    local gui = playerGui:FindFirstChild(name.."Gui")
    if gui then gui:Destroy() end
    gui = Instance.new("ScreenGui", playerGui)
    gui.Name = name.."Gui"
    gui.IgnoreGuiInset = true
    gui.ResetOnSpawn = false
    gui.Enabled = isMobile

    local frame = Instance.new("Frame", gui)
    frame.Size = UDim2.new(0, 60, 0, 60)
    frame.Position = UDim2.new(0.5, -30, 0.12 + yOffset, 0)
    frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    frame.BackgroundTransparency = 0.35
    frame.BorderSizePixel = 0
    makeDraggable(frame)

    local corner = Instance.new("UICorner", frame)
    corner.CornerRadius = UDim.new(0, 6)

    local stroke = Instance.new("UIStroke", frame)
    stroke.Color = Color3.fromRGB(150, 150, 150)
    stroke.Thickness = 2

    local label = Instance.new("TextLabel", frame)
    label.Text = name
    label.Size = UDim2.new(0.9, 0, 0.4, 0)
    label.Position = UDim2.new(0.05, 0, 0.05, 0)
    label.BackgroundTransparency = 1
    label.TextColor3 = Color3.fromRGB(255, 255, 255)
    label.Font = Enum.Font.Roboto
    label.TextSize = 20 
    label.TextXAlignment = Enum.TextXAlignment.Center
    label.TextYAlignment = Enum.TextYAlignment.Center

    local toggleBtn = Instance.new("TextButton", frame)
    toggleBtn.Name = "ToggleButton"
    toggleBtn.Text = getgenv()[varName] and "On" or "Off"
    toggleBtn.Size = UDim2.new(0.9, 0, 0.55, 0)
    toggleBtn.Position = UDim2.new(0.05, 0, 0.4, 0)
    toggleBtn.BackgroundColor3 = getgenv()[varName] and Color3.fromRGB(0, 100, 0) or Color3.fromRGB(0, 0, 0)
    toggleBtn.TextColor3 = Color3.fromRGB(255, 255, 255) 
    toggleBtn.Font = Enum.Font.Roboto
    toggleBtn.TextSize = 20 
    toggleBtn.TextXAlignment = Enum.TextXAlignment.Center
    toggleBtn.TextYAlignment = Enum.TextYAlignment.Center

    local buttonCorner = Instance.new("UICorner", toggleBtn)
    buttonCorner.CornerRadius = UDim.new(0, 4) 

    toggleBtn.MouseButton1Click:Connect(function()
        getgenv()[varName] = not getgenv()[varName]
        uiToggledViaUI = true
        toggleBtn.Text = getgenv()[varName] and "On" or "Off"
        toggleBtn.BackgroundColor3 = getgenv()[varName] and Color3.fromRGB(0, 100, 0) or Color3.fromRGB(0, 0, 0)
        gui.Enabled = true
    end)

    return gui, toggleBtn
end

local jumpGui, jumpToggleBtn
local MainTab = {}
MainTab.Toggle = function(self, config)
    config.Title = config.Title or "Toggle"
    config.Callback = config.Callback or function() end
    config.Value = config.Value or false

    local toggle = {
        Set = function(self, value)
            config.Value = value
            config.Callback(value)
        end
    }
    config.Callback(config.Value)
    return toggle
end

MainTab.Dropdown = function(self, config)
    config.Title = config.Title or "Dropdown"
    config.Values = config.Values or {}
    config.Multi = config.Multi or false
    config.Default = config.Default or (config.Multi and {} or config.Values[1])
    config.Callback = config.Callback or function() end

    local dropdown = {
        Select = function(self, value)
            config.Callback(value)
        end
    }
    config.Callback(config.Default)
    return dropdown
end

MainTab.Input = function(self, config)
    config.Title = config.Title or "Input"
    config.Placeholder = config.Placeholder or ""
    config.Value = config.Value or ""
    config.Callback = config.Callback or function() end

    local input = {
        Set = function(self, value)
            config.Callback(value)
        end
    }
    return input
end
end
if not featureStates then
    featureStates = {
        CustomGravity = false,
        GravityValue = workspace.Gravity
    }
end
local originalGameGravity = workspace.Gravity
local playerGui = game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui", 5)

local function makeDraggable(frame)
    frame.Active = true
    frame.Draggable = true
    
    local dragDetector = Instance.new("UIDragDetector")
    dragDetector.Parent = frame
    
    local originalBackground = frame.BackgroundColor3
    local originalTransparency = frame.BackgroundTransparency
    
    frame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            frame.BackgroundTransparency = originalTransparency - 0.1
        end
    end)
    
    frame.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            frame.BackgroundTransparency = originalTransparency
        end
    end)
end

local function createGravityGui(yOffset)
    local gravityGuiOld = playerGui:FindFirstChild("GravityGui")
    if gravityGuiOld then gravityGuiOld:Destroy() end
    
    local gravityGui = Instance.new("ScreenGui")
    gravityGui.Name = "GravityGui"
    gravityGui.IgnoreGuiInset = true
    gravityGui.ResetOnSpawn = false
    gravityGui.Enabled = getgenv().gravityGuiVisible
    gravityGui.Parent = playerGui

    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 60, 0, 60)
    frame.Position = UDim2.new(0.5, -30, 0.12 + (yOffset or 0), 0)
    frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    frame.BackgroundTransparency = 0.35
    frame.BorderSizePixel = 0
    frame.Parent = gravityGui
    makeDraggable(frame)

    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 6)
    corner.Parent = frame

    local stroke = Instance.new("UIStroke")
    stroke.Color = Color3.fromRGB(150, 150, 150)
    stroke.Thickness = 2
    stroke.Parent = frame

    local label = Instance.new("TextLabel")
    label.Text = "Gravity"
    label.Size = UDim2.new(0.9, 0, 0.5, 0)
    label.Position = UDim2.new(0.05, 0, 0, 0)
    label.BackgroundTransparency = 1
    label.TextColor3 = Color3.fromRGB(255, 255, 255)
    label.Font = Enum.Font.Roboto
    label.TextSize = 16
    label.TextXAlignment = Enum.TextXAlignment.Center
    label.TextYAlignment = Enum.TextYAlignment.Center
    label.TextScaled = true
    label.Parent = frame

    local gravityGuiButton = Instance.new("TextButton")
    gravityGuiButton.Name = "ToggleButton"
    gravityGuiButton.Text = featureStates.CustomGravity and "On" or "Off"
    gravityGuiButton.Size = UDim2.new(0.9, 0, 0.5, 0)
    gravityGuiButton.Position = UDim2.new(0.05, 0, 0.5, 0)
    gravityGuiButton.BackgroundColor3 = featureStates.CustomGravity and Color3.fromRGB(0, 120, 80) or Color3.fromRGB(120, 0, 0)
    gravityGuiButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    gravityGuiButton.Font = Enum.Font.Roboto
    gravityGuiButton.TextSize = 14
    gravityGuiButton.TextXAlignment = Enum.TextXAlignment.Center
    gravityGuiButton.TextYAlignment = Enum.TextYAlignment.Center
    gravityGuiButton.TextScaled = true
    gravityGuiButton.Parent = frame

    local buttonCorner = Instance.new("UICorner")
    buttonCorner.CornerRadius = UDim.new(0, 4)
    buttonCorner.Parent = gravityGuiButton

    gravityGuiButton.MouseButton1Click:Connect(function()
        featureStates.CustomGravity = not featureStates.CustomGravity
        if featureStates.CustomGravity then
            workspace.Gravity = featureStates.GravityValue
        else
            workspace.Gravity = originalGameGravity
        end
        gravityGuiButton.Text = featureStates.CustomGravity and "On" or "Off"
        gravityGuiButton.BackgroundColor3 = featureStates.CustomGravity and Color3.fromRGB(0, 120, 80) or Color3.fromRGB(120, 0, 0)
    end)
end

createGravityGui()

game:GetService("UserInputService").InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Enum.KeyCode.J and getgenv().gravityGuiVisible then
        featureStates.CustomGravity = not featureStates.CustomGravity
        if featureStates.CustomGravity then
            workspace.Gravity = featureStates.GravityValue
        else
            workspace.Gravity = originalGameGravity
        end
        local gravityGui = playerGui:FindFirstChild("GravityGui")
        if gravityGui then
            local button = gravityGui.Frame:FindFirstChild("ToggleButton")
            if button then
                button.Text = featureStates.CustomGravity and "On" or "Off"
                button.BackgroundColor3 = featureStates.CustomGravity and Color3.fromRGB(0, 120, 80) or Color3.fromRGB(120, 0, 0)
            end
        end
        WindUI:Notify({
            Title = "Gravity",
            Content = "Custom Gravity " .. (featureStates.CustomGravity and "enabled" or "disabled"),
            Duration = 2
        })
    end
end)

if featureStates.CustomGravity then
    workspace.Gravity = featureStates.GravityValue
else
    workspace.Gravity = originalGameGravity
end
local downedConnection = nil

local function setupDownedListener(character)
    if downedConnection then
        downedConnection:Disconnect()
        downedConnection = nil
    end
    
    if character then
        downedConnection = character:GetAttributeChangedSignal("Downed"):Connect(function()
            if character:GetAttribute("Downed") == true then
                deactivateFreecam()
            end
        end)
        
        if character:GetAttribute("Downed") == true then
            deactivateFreecam()
        end
    end
end

player.CharacterAdded:Connect(function(character)
    setupDownedListener(character)
end)

if player.Character then
    setupDownedListener(player.Character)
end

--[[the part of loadstring prevent error]]
loadstring(game:HttpGet('https://raw.githubusercontent.com/Pnsdgsa/Script-kids/refs/heads/main/Scripthub/Darahub/evade/More-Loadstrings.lua'))()
if not workspace:FindFirstChild("SecurityPart") then
    local SecurityPart = Instance.new("Part")
    SecurityPart.Name = "SecurityPart"
    SecurityPart.Size = Vector3.new(10, 1, 10)
    SecurityPart.Position = Vector3.new(0, 500, 0)
    SecurityPart.Anchored = true
    SecurityPart.CanCollide = true
    SecurityPart.Parent = workspace
end
   local Players = game:GetService("Players")
local player = Players.LocalPlayer

local featureStates = {
    ResetWhenTakeDamage = false,
    ResetDamageType = "Any Damage"
}

local function monitorAnyDamage()
    local function setupCharacter(character)
        local humanoid = character:WaitForChild("Humanoid")
        local lastHealth = humanoid.Health
        local isAlive = true
        
        local function checkAliveStatus()
            if character:GetAttribute("Downed") then
                return false
            end
            
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid and humanoid.Health > 0 then
                return true
            end
            
            return false
        end
        
        humanoid.HealthChanged:Connect(function(currentHealth)
            local wasAlive = isAlive
            isAlive = checkAliveStatus()
            
            if featureStates.ResetWhenTakeDamage and isAlive and currentHealth < lastHealth then
                if featureStates.ResetDamageType == "Any Damage" then
                    game:GetService("ReplicatedStorage").Events.Character.ToolAction:FireServer(-2)
                    
                    local sound = Instance.new("Sound")
                    sound.SoundId = "rbxassetid://8164951181"
                    sound.Volume = 3
                    sound.Parent = game:GetService("SoundService")
                    sound:Play()
                    
                    sound.Ended:Connect(function()
                        sound:Destroy()
                    end)
                elseif featureStates.ResetDamageType == "Low Health" and currentHealth <= 25 then
                    game:GetService("ReplicatedStorage").Events.Character.ToolAction:FireServer(-2)
                    
                    local sound = Instance.new("Sound")
                    sound.SoundId = "rbxassetid://8164951181"
                    sound.Volume = 3
                    sound.Parent = game:GetService("SoundService")
                    sound:Play()
                    
                    sound.Ended:Connect(function()
                        sound:Destroy()
                    end)
                end
            end
            
            lastHealth = currentHealth
        end)
        
        character:GetAttributeChangedSignal("Downed"):Connect(function()
            isAlive = not character:GetAttribute("Downed")
        end)
        
        isAlive = checkAliveStatus()
    end
    
    if player.Character then
        setupCharacter(player.Character)
    end
    player.CharacterAdded:Connect(setupCharacter)
end




monitorAnyDamage()
